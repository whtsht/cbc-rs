// This file is generated by xtencg. !!!DO NOT EDIT THIS FILE!!!

use super::encoding::*;
use super::operand::*;
use std::io;

pub trait WriteInstExt: io::Write {
    fn adcb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Adcb<Op0, Op1>: WriteInst<Self>,
    {
        Adcb(op0, op1).write_inst(self)
    }

    fn adcl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Adcl<Op0, Op1>: WriteInst<Self>,
    {
        Adcl(op0, op1).write_inst(self)
    }

    fn adcq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Adcq<Op0, Op1>: WriteInst<Self>,
    {
        Adcq(op0, op1).write_inst(self)
    }

    fn adcw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Adcw<Op0, Op1>: WriteInst<Self>,
    {
        Adcw(op0, op1).write_inst(self)
    }

    fn addb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addb<Op0, Op1>: WriteInst<Self>,
    {
        Addb(op0, op1).write_inst(self)
    }

    fn addl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addl<Op0, Op1>: WriteInst<Self>,
    {
        Addl(op0, op1).write_inst(self)
    }

    fn addpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addpd<Op0, Op1>: WriteInst<Self>,
    {
        Addpd(op0, op1).write_inst(self)
    }

    fn addps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addps<Op0, Op1>: WriteInst<Self>,
    {
        Addps(op0, op1).write_inst(self)
    }

    fn addq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addq<Op0, Op1>: WriteInst<Self>,
    {
        Addq(op0, op1).write_inst(self)
    }

    fn addsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addsd<Op0, Op1>: WriteInst<Self>,
    {
        Addsd(op0, op1).write_inst(self)
    }

    fn addss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addss<Op0, Op1>: WriteInst<Self>,
    {
        Addss(op0, op1).write_inst(self)
    }

    fn addw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Addw<Op0, Op1>: WriteInst<Self>,
    {
        Addw(op0, op1).write_inst(self)
    }

    fn andb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andb<Op0, Op1>: WriteInst<Self>,
    {
        Andb(op0, op1).write_inst(self)
    }

    fn andl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andl<Op0, Op1>: WriteInst<Self>,
    {
        Andl(op0, op1).write_inst(self)
    }

    fn andnpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andnpd<Op0, Op1>: WriteInst<Self>,
    {
        Andnpd(op0, op1).write_inst(self)
    }

    fn andnps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andnps<Op0, Op1>: WriteInst<Self>,
    {
        Andnps(op0, op1).write_inst(self)
    }

    fn andpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andpd<Op0, Op1>: WriteInst<Self>,
    {
        Andpd(op0, op1).write_inst(self)
    }

    fn andps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andps<Op0, Op1>: WriteInst<Self>,
    {
        Andps(op0, op1).write_inst(self)
    }

    fn andq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andq<Op0, Op1>: WriteInst<Self>,
    {
        Andq(op0, op1).write_inst(self)
    }

    fn andw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Andw<Op0, Op1>: WriteInst<Self>,
    {
        Andw(op0, op1).write_inst(self)
    }

    fn blendpd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Blendpd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Blendpd(op0, op1, op2).write_inst(self)
    }

    fn blendps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Blendps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Blendps(op0, op1, op2).write_inst(self)
    }

    fn blendvpd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Blendvpd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Blendvpd(op0, op1, op2).write_inst(self)
    }

    fn blendvps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Blendvps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Blendvps(op0, op1, op2).write_inst(self)
    }

    fn bsfl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Bsfl<Op0, Op1>: WriteInst<Self>,
    {
        Bsfl(op0, op1).write_inst(self)
    }

    fn bsfq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Bsfq<Op0, Op1>: WriteInst<Self>,
    {
        Bsfq(op0, op1).write_inst(self)
    }

    fn bsfw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Bsfw<Op0, Op1>: WriteInst<Self>,
    {
        Bsfw(op0, op1).write_inst(self)
    }

    fn bsrl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Bsrl<Op0, Op1>: WriteInst<Self>,
    {
        Bsrl(op0, op1).write_inst(self)
    }

    fn bsrq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Bsrq<Op0, Op1>: WriteInst<Self>,
    {
        Bsrq(op0, op1).write_inst(self)
    }

    fn bsrw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Bsrw<Op0, Op1>: WriteInst<Self>,
    {
        Bsrw(op0, op1).write_inst(self)
    }

    fn bswap<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Bswap<Op0>: WriteInst<Self>,
    {
        Bswap(op0).write_inst(self)
    }

    fn btcl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btcl<Op0, Op1>: WriteInst<Self>,
    {
        Btcl(op0, op1).write_inst(self)
    }

    fn btcq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btcq<Op0, Op1>: WriteInst<Self>,
    {
        Btcq(op0, op1).write_inst(self)
    }

    fn btcw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btcw<Op0, Op1>: WriteInst<Self>,
    {
        Btcw(op0, op1).write_inst(self)
    }

    fn btl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btl<Op0, Op1>: WriteInst<Self>,
    {
        Btl(op0, op1).write_inst(self)
    }

    fn btq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btq<Op0, Op1>: WriteInst<Self>,
    {
        Btq(op0, op1).write_inst(self)
    }

    fn btrl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btrl<Op0, Op1>: WriteInst<Self>,
    {
        Btrl(op0, op1).write_inst(self)
    }

    fn btrq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btrq<Op0, Op1>: WriteInst<Self>,
    {
        Btrq(op0, op1).write_inst(self)
    }

    fn btrw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btrw<Op0, Op1>: WriteInst<Self>,
    {
        Btrw(op0, op1).write_inst(self)
    }

    fn btsl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btsl<Op0, Op1>: WriteInst<Self>,
    {
        Btsl(op0, op1).write_inst(self)
    }

    fn btsq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btsq<Op0, Op1>: WriteInst<Self>,
    {
        Btsq(op0, op1).write_inst(self)
    }

    fn btsw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btsw<Op0, Op1>: WriteInst<Self>,
    {
        Btsw(op0, op1).write_inst(self)
    }

    fn btw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Btw<Op0, Op1>: WriteInst<Self>,
    {
        Btw(op0, op1).write_inst(self)
    }

    fn callq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Callq<Op0>: WriteInst<Self>,
    {
        Callq(op0).write_inst(self)
    }

    fn cbtw(&mut self) -> io::Result<()> {
        Cbtw().write_inst(self)
    }

    fn clc(&mut self) -> io::Result<()> {
        Clc().write_inst(self)
    }

    fn cld(&mut self) -> io::Result<()> {
        Cld().write_inst(self)
    }

    fn cli(&mut self) -> io::Result<()> {
        Cli().write_inst(self)
    }

    fn cltd(&mut self) -> io::Result<()> {
        Cltd().write_inst(self)
    }

    fn cltq(&mut self) -> io::Result<()> {
        Cltq().write_inst(self)
    }

    fn clts(&mut self) -> io::Result<()> {
        Clts().write_inst(self)
    }

    fn cmc(&mut self) -> io::Result<()> {
        Cmc().write_inst(self)
    }

    fn cmpb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpb<Op0, Op1>: WriteInst<Self>,
    {
        Cmpb(op0, op1).write_inst(self)
    }

    fn cmpl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpl<Op0, Op1>: WriteInst<Self>,
    {
        Cmpl(op0, op1).write_inst(self)
    }

    fn cmppd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Cmppd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Cmppd(op0, op1, op2).write_inst(self)
    }

    fn cmpps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Cmpps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Cmpps(op0, op1, op2).write_inst(self)
    }

    fn cmpq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpq<Op0, Op1>: WriteInst<Self>,
    {
        Cmpq(op0, op1).write_inst(self)
    }

    fn cmpsd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Cmpsd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Cmpsd(op0, op1, op2).write_inst(self)
    }

    fn cmpsl(&mut self) -> io::Result<()> {
        Cmpsl().write_inst(self)
    }

    fn cmpss<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Cmpss<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Cmpss(op0, op1, op2).write_inst(self)
    }

    fn cmpw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpw<Op0, Op1>: WriteInst<Self>,
    {
        Cmpw(op0, op1).write_inst(self)
    }

    fn cmpxchgb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpxchgb<Op0, Op1>: WriteInst<Self>,
    {
        Cmpxchgb(op0, op1).write_inst(self)
    }

    fn cmpxchgl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpxchgl<Op0, Op1>: WriteInst<Self>,
    {
        Cmpxchgl(op0, op1).write_inst(self)
    }

    fn cmpxchgq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpxchgq<Op0, Op1>: WriteInst<Self>,
    {
        Cmpxchgq(op0, op1).write_inst(self)
    }

    fn cmpxchgw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cmpxchgw<Op0, Op1>: WriteInst<Self>,
    {
        Cmpxchgw(op0, op1).write_inst(self)
    }

    fn comisd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Comisd<Op0, Op1>: WriteInst<Self>,
    {
        Comisd(op0, op1).write_inst(self)
    }

    fn comiss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Comiss<Op0, Op1>: WriteInst<Self>,
    {
        Comiss(op0, op1).write_inst(self)
    }

    fn cpuid(&mut self) -> io::Result<()> {
        Cpuid().write_inst(self)
    }

    fn cqto(&mut self) -> io::Result<()> {
        Cqto().write_inst(self)
    }

    fn crc32b<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Crc32b<Op0, Op1>: WriteInst<Self>,
    {
        Crc32b(op0, op1).write_inst(self)
    }

    fn crc32l<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Crc32l<Op0, Op1>: WriteInst<Self>,
    {
        Crc32l(op0, op1).write_inst(self)
    }

    fn crc32q<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Crc32q<Op0, Op1>: WriteInst<Self>,
    {
        Crc32q(op0, op1).write_inst(self)
    }

    fn crc32w<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Crc32w<Op0, Op1>: WriteInst<Self>,
    {
        Crc32w(op0, op1).write_inst(self)
    }

    fn cvtdq2pd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtdq2pd<Op0, Op1>: WriteInst<Self>,
    {
        Cvtdq2pd(op0, op1).write_inst(self)
    }

    fn cvtdq2ps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtdq2ps<Op0, Op1>: WriteInst<Self>,
    {
        Cvtdq2ps(op0, op1).write_inst(self)
    }

    fn cvtpd2dq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtpd2dq<Op0, Op1>: WriteInst<Self>,
    {
        Cvtpd2dq(op0, op1).write_inst(self)
    }

    fn cvtpd2ps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtpd2ps<Op0, Op1>: WriteInst<Self>,
    {
        Cvtpd2ps(op0, op1).write_inst(self)
    }

    fn cvtps2dq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtps2dq<Op0, Op1>: WriteInst<Self>,
    {
        Cvtps2dq(op0, op1).write_inst(self)
    }

    fn cvtps2pd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtps2pd<Op0, Op1>: WriteInst<Self>,
    {
        Cvtps2pd(op0, op1).write_inst(self)
    }

    fn cvtsd2si<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtsd2si<Op0, Op1>: WriteInst<Self>,
    {
        Cvtsd2si(op0, op1).write_inst(self)
    }

    fn cvtsd2ss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtsd2ss<Op0, Op1>: WriteInst<Self>,
    {
        Cvtsd2ss(op0, op1).write_inst(self)
    }

    fn cvtsi2sdl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtsi2sdl<Op0, Op1>: WriteInst<Self>,
    {
        Cvtsi2sdl(op0, op1).write_inst(self)
    }

    fn cvtsi2sdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtsi2sdq<Op0, Op1>: WriteInst<Self>,
    {
        Cvtsi2sdq(op0, op1).write_inst(self)
    }

    fn cvtsi2ssl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtsi2ssl<Op0, Op1>: WriteInst<Self>,
    {
        Cvtsi2ssl(op0, op1).write_inst(self)
    }

    fn cvtsi2ssq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtsi2ssq<Op0, Op1>: WriteInst<Self>,
    {
        Cvtsi2ssq(op0, op1).write_inst(self)
    }

    fn cvtss2sd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtss2sd<Op0, Op1>: WriteInst<Self>,
    {
        Cvtss2sd(op0, op1).write_inst(self)
    }

    fn cvtss2si<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvtss2si<Op0, Op1>: WriteInst<Self>,
    {
        Cvtss2si(op0, op1).write_inst(self)
    }

    fn cvttpd2dq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvttpd2dq<Op0, Op1>: WriteInst<Self>,
    {
        Cvttpd2dq(op0, op1).write_inst(self)
    }

    fn cvttps2dq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvttps2dq<Op0, Op1>: WriteInst<Self>,
    {
        Cvttps2dq(op0, op1).write_inst(self)
    }

    fn cvttsd2si<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvttsd2si<Op0, Op1>: WriteInst<Self>,
    {
        Cvttsd2si(op0, op1).write_inst(self)
    }

    fn cvttss2si<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Cvttss2si<Op0, Op1>: WriteInst<Self>,
    {
        Cvttss2si(op0, op1).write_inst(self)
    }

    fn cwtd(&mut self) -> io::Result<()> {
        Cwtd().write_inst(self)
    }

    fn cwtl(&mut self) -> io::Result<()> {
        Cwtl().write_inst(self)
    }

    fn decb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Decb<Op0>: WriteInst<Self>,
    {
        Decb(op0).write_inst(self)
    }

    fn decl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Decl<Op0>: WriteInst<Self>,
    {
        Decl(op0).write_inst(self)
    }

    fn decq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Decq<Op0>: WriteInst<Self>,
    {
        Decq(op0).write_inst(self)
    }

    fn decw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Decw<Op0>: WriteInst<Self>,
    {
        Decw(op0).write_inst(self)
    }

    fn divb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Divb<Op0>: WriteInst<Self>,
    {
        Divb(op0).write_inst(self)
    }

    fn divl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Divl<Op0>: WriteInst<Self>,
    {
        Divl(op0).write_inst(self)
    }

    fn divpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Divpd<Op0, Op1>: WriteInst<Self>,
    {
        Divpd(op0, op1).write_inst(self)
    }

    fn divps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Divps<Op0, Op1>: WriteInst<Self>,
    {
        Divps(op0, op1).write_inst(self)
    }

    fn divq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Divq<Op0>: WriteInst<Self>,
    {
        Divq(op0).write_inst(self)
    }

    fn divsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Divsd<Op0, Op1>: WriteInst<Self>,
    {
        Divsd(op0, op1).write_inst(self)
    }

    fn divss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Divss<Op0, Op1>: WriteInst<Self>,
    {
        Divss(op0, op1).write_inst(self)
    }

    fn divw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Divw<Op0>: WriteInst<Self>,
    {
        Divw(op0).write_inst(self)
    }

    fn dppd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Dppd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Dppd(op0, op1, op2).write_inst(self)
    }

    fn dpps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Dpps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Dpps(op0, op1, op2).write_inst(self)
    }

    fn emms(&mut self) -> io::Result<()> {
        Emms().write_inst(self)
    }

    fn extractps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Extractps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Extractps(op0, op1, op2).write_inst(self)
    }

    fn hlt(&mut self) -> io::Result<()> {
        Hlt().write_inst(self)
    }

    fn idivb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Idivb<Op0>: WriteInst<Self>,
    {
        Idivb(op0).write_inst(self)
    }

    fn idivl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Idivl<Op0>: WriteInst<Self>,
    {
        Idivl(op0).write_inst(self)
    }

    fn idivq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Idivq<Op0>: WriteInst<Self>,
    {
        Idivq(op0).write_inst(self)
    }

    fn idivw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Idivw<Op0>: WriteInst<Self>,
    {
        Idivw(op0).write_inst(self)
    }

    fn imulb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Imulb<Op0>: WriteInst<Self>,
    {
        Imulb(op0).write_inst(self)
    }

    fn imull<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Imull<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Imull(op0, op1, op2).write_inst(self)
    }

    fn imull1<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Imull1<Op0>: WriteInst<Self>,
    {
        Imull1(op0).write_inst(self)
    }

    fn imull2<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Imull2<Op0, Op1>: WriteInst<Self>,
    {
        Imull2(op0, op1).write_inst(self)
    }

    fn imulq<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Imulq<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Imulq(op0, op1, op2).write_inst(self)
    }

    fn imulq1<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Imulq1<Op0>: WriteInst<Self>,
    {
        Imulq1(op0).write_inst(self)
    }

    fn imulq2<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Imulq2<Op0, Op1>: WriteInst<Self>,
    {
        Imulq2(op0, op1).write_inst(self)
    }

    fn imulw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Imulw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Imulw(op0, op1, op2).write_inst(self)
    }

    fn imulw1<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Imulw1<Op0>: WriteInst<Self>,
    {
        Imulw1(op0).write_inst(self)
    }

    fn imulw2<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Imulw2<Op0, Op1>: WriteInst<Self>,
    {
        Imulw2(op0, op1).write_inst(self)
    }

    fn inb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Inb<Op0, Op1>: WriteInst<Self>,
    {
        Inb(op0, op1).write_inst(self)
    }

    fn incb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Incb<Op0>: WriteInst<Self>,
    {
        Incb(op0).write_inst(self)
    }

    fn incl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Incl<Op0>: WriteInst<Self>,
    {
        Incl(op0).write_inst(self)
    }

    fn incq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Incq<Op0>: WriteInst<Self>,
    {
        Incq(op0).write_inst(self)
    }

    fn incw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Incw<Op0>: WriteInst<Self>,
    {
        Incw(op0).write_inst(self)
    }

    fn inl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Inl<Op0, Op1>: WriteInst<Self>,
    {
        Inl(op0, op1).write_inst(self)
    }

    fn insertps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Insertps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Insertps(op0, op1, op2).write_inst(self)
    }

    fn int<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Int<Op0>: WriteInst<Self>,
    {
        Int(op0).write_inst(self)
    }

    fn invd(&mut self) -> io::Result<()> {
        Invd().write_inst(self)
    }

    fn invlpg<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Invlpg<Op0>: WriteInst<Self>,
    {
        Invlpg(op0).write_inst(self)
    }

    fn inw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Inw<Op0, Op1>: WriteInst<Self>,
    {
        Inw(op0, op1).write_inst(self)
    }

    fn iretl(&mut self) -> io::Result<()> {
        Iretl().write_inst(self)
    }

    fn iretq(&mut self) -> io::Result<()> {
        Iretq().write_inst(self)
    }

    fn iretw(&mut self) -> io::Result<()> {
        Iretw().write_inst(self)
    }

    fn ja<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Ja<Op0>: WriteInst<Self>,
    {
        Ja(op0).write_inst(self)
    }

    fn jae<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jae<Op0>: WriteInst<Self>,
    {
        Jae(op0).write_inst(self)
    }

    fn jb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jb<Op0>: WriteInst<Self>,
    {
        Jb(op0).write_inst(self)
    }

    fn jbe<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jbe<Op0>: WriteInst<Self>,
    {
        Jbe(op0).write_inst(self)
    }

    fn jc<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jc<Op0>: WriteInst<Self>,
    {
        Jc(op0).write_inst(self)
    }

    fn je<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Je<Op0>: WriteInst<Self>,
    {
        Je(op0).write_inst(self)
    }

    fn jecxz<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jecxz<Op0>: WriteInst<Self>,
    {
        Jecxz(op0).write_inst(self)
    }

    fn jg<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jg<Op0>: WriteInst<Self>,
    {
        Jg(op0).write_inst(self)
    }

    fn jge<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jge<Op0>: WriteInst<Self>,
    {
        Jge(op0).write_inst(self)
    }

    fn jl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jl<Op0>: WriteInst<Self>,
    {
        Jl(op0).write_inst(self)
    }

    fn jle<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jle<Op0>: WriteInst<Self>,
    {
        Jle(op0).write_inst(self)
    }

    fn jmpq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jmpq<Op0>: WriteInst<Self>,
    {
        Jmpq(op0).write_inst(self)
    }

    fn jna<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jna<Op0>: WriteInst<Self>,
    {
        Jna(op0).write_inst(self)
    }

    fn jnae<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnae<Op0>: WriteInst<Self>,
    {
        Jnae(op0).write_inst(self)
    }

    fn jnb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnb<Op0>: WriteInst<Self>,
    {
        Jnb(op0).write_inst(self)
    }

    fn jnbe<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnbe<Op0>: WriteInst<Self>,
    {
        Jnbe(op0).write_inst(self)
    }

    fn jnc<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnc<Op0>: WriteInst<Self>,
    {
        Jnc(op0).write_inst(self)
    }

    fn jne<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jne<Op0>: WriteInst<Self>,
    {
        Jne(op0).write_inst(self)
    }

    fn jng<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jng<Op0>: WriteInst<Self>,
    {
        Jng(op0).write_inst(self)
    }

    fn jnge<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnge<Op0>: WriteInst<Self>,
    {
        Jnge(op0).write_inst(self)
    }

    fn jnl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnl<Op0>: WriteInst<Self>,
    {
        Jnl(op0).write_inst(self)
    }

    fn jnle<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnle<Op0>: WriteInst<Self>,
    {
        Jnle(op0).write_inst(self)
    }

    fn jno<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jno<Op0>: WriteInst<Self>,
    {
        Jno(op0).write_inst(self)
    }

    fn jnp<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnp<Op0>: WriteInst<Self>,
    {
        Jnp(op0).write_inst(self)
    }

    fn jns<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jns<Op0>: WriteInst<Self>,
    {
        Jns(op0).write_inst(self)
    }

    fn jnz<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jnz<Op0>: WriteInst<Self>,
    {
        Jnz(op0).write_inst(self)
    }

    fn jo<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jo<Op0>: WriteInst<Self>,
    {
        Jo(op0).write_inst(self)
    }

    fn jp<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jp<Op0>: WriteInst<Self>,
    {
        Jp(op0).write_inst(self)
    }

    fn jpe<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jpe<Op0>: WriteInst<Self>,
    {
        Jpe(op0).write_inst(self)
    }

    fn jpo<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jpo<Op0>: WriteInst<Self>,
    {
        Jpo(op0).write_inst(self)
    }

    fn jrcxz<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jrcxz<Op0>: WriteInst<Self>,
    {
        Jrcxz(op0).write_inst(self)
    }

    fn js<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Js<Op0>: WriteInst<Self>,
    {
        Js(op0).write_inst(self)
    }

    fn jz<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Jz<Op0>: WriteInst<Self>,
    {
        Jz(op0).write_inst(self)
    }

    fn ldmxcsr<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Ldmxcsr<Op0>: WriteInst<Self>,
    {
        Ldmxcsr(op0).write_inst(self)
    }

    fn leal<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Leal<Op0, Op1>: WriteInst<Self>,
    {
        Leal(op0, op1).write_inst(self)
    }

    fn leaq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Leaq<Op0, Op1>: WriteInst<Self>,
    {
        Leaq(op0, op1).write_inst(self)
    }

    fn leaveq(&mut self) -> io::Result<()> {
        Leaveq().write_inst(self)
    }

    fn leavew(&mut self) -> io::Result<()> {
        Leavew().write_inst(self)
    }

    fn leaw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Leaw<Op0, Op1>: WriteInst<Self>,
    {
        Leaw(op0, op1).write_inst(self)
    }

    fn lfence(&mut self) -> io::Result<()> {
        Lfence().write_inst(self)
    }

    fn lmsw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Lmsw<Op0>: WriteInst<Self>,
    {
        Lmsw(op0).write_inst(self)
    }

    fn lock(&mut self) -> io::Result<()> {
        Lock().write_inst(self)
    }

    fn maskmovdqu<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Maskmovdqu<Op0, Op1>: WriteInst<Self>,
    {
        Maskmovdqu(op0, op1).write_inst(self)
    }

    fn maxpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Maxpd<Op0, Op1>: WriteInst<Self>,
    {
        Maxpd(op0, op1).write_inst(self)
    }

    fn maxps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Maxps<Op0, Op1>: WriteInst<Self>,
    {
        Maxps(op0, op1).write_inst(self)
    }

    fn maxsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Maxsd<Op0, Op1>: WriteInst<Self>,
    {
        Maxsd(op0, op1).write_inst(self)
    }

    fn maxss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Maxss<Op0, Op1>: WriteInst<Self>,
    {
        Maxss(op0, op1).write_inst(self)
    }

    fn mfence(&mut self) -> io::Result<()> {
        Mfence().write_inst(self)
    }

    fn minpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Minpd<Op0, Op1>: WriteInst<Self>,
    {
        Minpd(op0, op1).write_inst(self)
    }

    fn minps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Minps<Op0, Op1>: WriteInst<Self>,
    {
        Minps(op0, op1).write_inst(self)
    }

    fn minsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Minsd<Op0, Op1>: WriteInst<Self>,
    {
        Minsd(op0, op1).write_inst(self)
    }

    fn minss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Minss<Op0, Op1>: WriteInst<Self>,
    {
        Minss(op0, op1).write_inst(self)
    }

    fn movapd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movapd<Op0, Op1>: WriteInst<Self>,
    {
        Movapd(op0, op1).write_inst(self)
    }

    fn movaps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movaps<Op0, Op1>: WriteInst<Self>,
    {
        Movaps(op0, op1).write_inst(self)
    }

    fn movb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movb<Op0, Op1>: WriteInst<Self>,
    {
        Movb(op0, op1).write_inst(self)
    }

    fn movd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movd<Op0, Op1>: WriteInst<Self>,
    {
        Movd(op0, op1).write_inst(self)
    }

    fn movdqa<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movdqa<Op0, Op1>: WriteInst<Self>,
    {
        Movdqa(op0, op1).write_inst(self)
    }

    fn movdqu<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movdqu<Op0, Op1>: WriteInst<Self>,
    {
        Movdqu(op0, op1).write_inst(self)
    }

    fn movhlps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movhlps<Op0, Op1>: WriteInst<Self>,
    {
        Movhlps(op0, op1).write_inst(self)
    }

    fn movhpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movhpd<Op0, Op1>: WriteInst<Self>,
    {
        Movhpd(op0, op1).write_inst(self)
    }

    fn movhps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movhps<Op0, Op1>: WriteInst<Self>,
    {
        Movhps(op0, op1).write_inst(self)
    }

    fn movl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movl<Op0, Op1>: WriteInst<Self>,
    {
        Movl(op0, op1).write_inst(self)
    }

    fn movlhps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movlhps<Op0, Op1>: WriteInst<Self>,
    {
        Movlhps(op0, op1).write_inst(self)
    }

    fn movlpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movlpd<Op0, Op1>: WriteInst<Self>,
    {
        Movlpd(op0, op1).write_inst(self)
    }

    fn movlps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movlps<Op0, Op1>: WriteInst<Self>,
    {
        Movlps(op0, op1).write_inst(self)
    }

    fn movmskpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movmskpd<Op0, Op1>: WriteInst<Self>,
    {
        Movmskpd(op0, op1).write_inst(self)
    }

    fn movmskps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movmskps<Op0, Op1>: WriteInst<Self>,
    {
        Movmskps(op0, op1).write_inst(self)
    }

    fn movntdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movntdq<Op0, Op1>: WriteInst<Self>,
    {
        Movntdq(op0, op1).write_inst(self)
    }

    fn movntdqa<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movntdqa<Op0, Op1>: WriteInst<Self>,
    {
        Movntdqa(op0, op1).write_inst(self)
    }

    fn movnti<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movnti<Op0, Op1>: WriteInst<Self>,
    {
        Movnti(op0, op1).write_inst(self)
    }

    fn movntpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movntpd<Op0, Op1>: WriteInst<Self>,
    {
        Movntpd(op0, op1).write_inst(self)
    }

    fn movntps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movntps<Op0, Op1>: WriteInst<Self>,
    {
        Movntps(op0, op1).write_inst(self)
    }

    fn movq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movq<Op0, Op1>: WriteInst<Self>,
    {
        Movq(op0, op1).write_inst(self)
    }

    fn movsbl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movsbl<Op0, Op1>: WriteInst<Self>,
    {
        Movsbl(op0, op1).write_inst(self)
    }

    fn movsbq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movsbq<Op0, Op1>: WriteInst<Self>,
    {
        Movsbq(op0, op1).write_inst(self)
    }

    fn movsbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movsbw<Op0, Op1>: WriteInst<Self>,
    {
        Movsbw(op0, op1).write_inst(self)
    }

    fn movsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movsd<Op0, Op1>: WriteInst<Self>,
    {
        Movsd(op0, op1).write_inst(self)
    }

    fn movsl(&mut self) -> io::Result<()> {
        Movsl().write_inst(self)
    }

    fn movslq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movslq<Op0, Op1>: WriteInst<Self>,
    {
        Movslq(op0, op1).write_inst(self)
    }

    fn movss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movss<Op0, Op1>: WriteInst<Self>,
    {
        Movss(op0, op1).write_inst(self)
    }

    fn movswl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movswl<Op0, Op1>: WriteInst<Self>,
    {
        Movswl(op0, op1).write_inst(self)
    }

    fn movswq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movswq<Op0, Op1>: WriteInst<Self>,
    {
        Movswq(op0, op1).write_inst(self)
    }

    fn movupd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movupd<Op0, Op1>: WriteInst<Self>,
    {
        Movupd(op0, op1).write_inst(self)
    }

    fn movups<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movups<Op0, Op1>: WriteInst<Self>,
    {
        Movups(op0, op1).write_inst(self)
    }

    fn movw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movw<Op0, Op1>: WriteInst<Self>,
    {
        Movw(op0, op1).write_inst(self)
    }

    fn movzbl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movzbl<Op0, Op1>: WriteInst<Self>,
    {
        Movzbl(op0, op1).write_inst(self)
    }

    fn movzbq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movzbq<Op0, Op1>: WriteInst<Self>,
    {
        Movzbq(op0, op1).write_inst(self)
    }

    fn movzbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movzbw<Op0, Op1>: WriteInst<Self>,
    {
        Movzbw(op0, op1).write_inst(self)
    }

    fn movzwl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movzwl<Op0, Op1>: WriteInst<Self>,
    {
        Movzwl(op0, op1).write_inst(self)
    }

    fn movzwq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Movzwq<Op0, Op1>: WriteInst<Self>,
    {
        Movzwq(op0, op1).write_inst(self)
    }

    fn mpsadbw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Mpsadbw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Mpsadbw(op0, op1, op2).write_inst(self)
    }

    fn mulb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Mulb<Op0>: WriteInst<Self>,
    {
        Mulb(op0).write_inst(self)
    }

    fn mull<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Mull<Op0>: WriteInst<Self>,
    {
        Mull(op0).write_inst(self)
    }

    fn mulpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Mulpd<Op0, Op1>: WriteInst<Self>,
    {
        Mulpd(op0, op1).write_inst(self)
    }

    fn mulps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Mulps<Op0, Op1>: WriteInst<Self>,
    {
        Mulps(op0, op1).write_inst(self)
    }

    fn mulq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Mulq<Op0>: WriteInst<Self>,
    {
        Mulq(op0).write_inst(self)
    }

    fn mulsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Mulsd<Op0, Op1>: WriteInst<Self>,
    {
        Mulsd(op0, op1).write_inst(self)
    }

    fn mulss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Mulss<Op0, Op1>: WriteInst<Self>,
    {
        Mulss(op0, op1).write_inst(self)
    }

    fn mulw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Mulw<Op0>: WriteInst<Self>,
    {
        Mulw(op0).write_inst(self)
    }

    fn negb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Negb<Op0>: WriteInst<Self>,
    {
        Negb(op0).write_inst(self)
    }

    fn negl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Negl<Op0>: WriteInst<Self>,
    {
        Negl(op0).write_inst(self)
    }

    fn negq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Negq<Op0>: WriteInst<Self>,
    {
        Negq(op0).write_inst(self)
    }

    fn negw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Negw<Op0>: WriteInst<Self>,
    {
        Negw(op0).write_inst(self)
    }

    fn nop(&mut self) -> io::Result<()> {
        Nop().write_inst(self)
    }

    fn notb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Notb<Op0>: WriteInst<Self>,
    {
        Notb(op0).write_inst(self)
    }

    fn notl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Notl<Op0>: WriteInst<Self>,
    {
        Notl(op0).write_inst(self)
    }

    fn notq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Notq<Op0>: WriteInst<Self>,
    {
        Notq(op0).write_inst(self)
    }

    fn notw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Notw<Op0>: WriteInst<Self>,
    {
        Notw(op0).write_inst(self)
    }

    fn orb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Orb<Op0, Op1>: WriteInst<Self>,
    {
        Orb(op0, op1).write_inst(self)
    }

    fn orl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Orl<Op0, Op1>: WriteInst<Self>,
    {
        Orl(op0, op1).write_inst(self)
    }

    fn orpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Orpd<Op0, Op1>: WriteInst<Self>,
    {
        Orpd(op0, op1).write_inst(self)
    }

    fn orps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Orps<Op0, Op1>: WriteInst<Self>,
    {
        Orps(op0, op1).write_inst(self)
    }

    fn orq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Orq<Op0, Op1>: WriteInst<Self>,
    {
        Orq(op0, op1).write_inst(self)
    }

    fn orw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Orw<Op0, Op1>: WriteInst<Self>,
    {
        Orw(op0, op1).write_inst(self)
    }

    fn outb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Outb<Op0, Op1>: WriteInst<Self>,
    {
        Outb(op0, op1).write_inst(self)
    }

    fn outl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Outl<Op0, Op1>: WriteInst<Self>,
    {
        Outl(op0, op1).write_inst(self)
    }

    fn outw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Outw<Op0, Op1>: WriteInst<Self>,
    {
        Outw(op0, op1).write_inst(self)
    }

    fn packssdw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Packssdw<Op0, Op1>: WriteInst<Self>,
    {
        Packssdw(op0, op1).write_inst(self)
    }

    fn packsswb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Packsswb<Op0, Op1>: WriteInst<Self>,
    {
        Packsswb(op0, op1).write_inst(self)
    }

    fn packusdw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Packusdw<Op0, Op1>: WriteInst<Self>,
    {
        Packusdw(op0, op1).write_inst(self)
    }

    fn packuswb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Packuswb<Op0, Op1>: WriteInst<Self>,
    {
        Packuswb(op0, op1).write_inst(self)
    }

    fn paddb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddb<Op0, Op1>: WriteInst<Self>,
    {
        Paddb(op0, op1).write_inst(self)
    }

    fn paddd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddd<Op0, Op1>: WriteInst<Self>,
    {
        Paddd(op0, op1).write_inst(self)
    }

    fn paddq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddq<Op0, Op1>: WriteInst<Self>,
    {
        Paddq(op0, op1).write_inst(self)
    }

    fn paddsb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddsb<Op0, Op1>: WriteInst<Self>,
    {
        Paddsb(op0, op1).write_inst(self)
    }

    fn paddsw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddsw<Op0, Op1>: WriteInst<Self>,
    {
        Paddsw(op0, op1).write_inst(self)
    }

    fn paddusb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddusb<Op0, Op1>: WriteInst<Self>,
    {
        Paddusb(op0, op1).write_inst(self)
    }

    fn paddusw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddusw<Op0, Op1>: WriteInst<Self>,
    {
        Paddusw(op0, op1).write_inst(self)
    }

    fn paddw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Paddw<Op0, Op1>: WriteInst<Self>,
    {
        Paddw(op0, op1).write_inst(self)
    }

    fn pand<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pand<Op0, Op1>: WriteInst<Self>,
    {
        Pand(op0, op1).write_inst(self)
    }

    fn pandn<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pandn<Op0, Op1>: WriteInst<Self>,
    {
        Pandn(op0, op1).write_inst(self)
    }

    fn pause(&mut self) -> io::Result<()> {
        Pause().write_inst(self)
    }

    fn pavgb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pavgb<Op0, Op1>: WriteInst<Self>,
    {
        Pavgb(op0, op1).write_inst(self)
    }

    fn pavgw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pavgw<Op0, Op1>: WriteInst<Self>,
    {
        Pavgw(op0, op1).write_inst(self)
    }

    fn pblendvb<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pblendvb<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pblendvb(op0, op1, op2).write_inst(self)
    }

    fn pblendw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pblendw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pblendw(op0, op1, op2).write_inst(self)
    }

    fn pcmpeqb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpeqb<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpeqb(op0, op1).write_inst(self)
    }

    fn pcmpeqd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpeqd<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpeqd(op0, op1).write_inst(self)
    }

    fn pcmpeqq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpeqq<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpeqq(op0, op1).write_inst(self)
    }

    fn pcmpeqw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpeqw<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpeqw(op0, op1).write_inst(self)
    }

    fn pcmpestri<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pcmpestri<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pcmpestri(op0, op1, op2).write_inst(self)
    }

    fn pcmpestrm<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pcmpestrm<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pcmpestrm(op0, op1, op2).write_inst(self)
    }

    fn pcmpgtb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpgtb<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpgtb(op0, op1).write_inst(self)
    }

    fn pcmpgtd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpgtd<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpgtd(op0, op1).write_inst(self)
    }

    fn pcmpgtq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpgtq<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpgtq(op0, op1).write_inst(self)
    }

    fn pcmpgtw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pcmpgtw<Op0, Op1>: WriteInst<Self>,
    {
        Pcmpgtw(op0, op1).write_inst(self)
    }

    fn pcmpistri<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pcmpistri<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pcmpistri(op0, op1, op2).write_inst(self)
    }

    fn pcmpistrm<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pcmpistrm<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pcmpistrm(op0, op1, op2).write_inst(self)
    }

    fn pextrb<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pextrb<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pextrb(op0, op1, op2).write_inst(self)
    }

    fn pextrd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pextrd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pextrd(op0, op1, op2).write_inst(self)
    }

    fn pextrq<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pextrq<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pextrq(op0, op1, op2).write_inst(self)
    }

    fn pextrw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pextrw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pextrw(op0, op1, op2).write_inst(self)
    }

    fn phminposuw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Phminposuw<Op0, Op1>: WriteInst<Self>,
    {
        Phminposuw(op0, op1).write_inst(self)
    }

    fn pinsrb<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pinsrb<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pinsrb(op0, op1, op2).write_inst(self)
    }

    fn pinsrd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pinsrd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pinsrd(op0, op1, op2).write_inst(self)
    }

    fn pinsrw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pinsrw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pinsrw(op0, op1, op2).write_inst(self)
    }

    fn pmaddwd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaddwd<Op0, Op1>: WriteInst<Self>,
    {
        Pmaddwd(op0, op1).write_inst(self)
    }

    fn pmaxsb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaxsb<Op0, Op1>: WriteInst<Self>,
    {
        Pmaxsb(op0, op1).write_inst(self)
    }

    fn pmaxsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaxsd<Op0, Op1>: WriteInst<Self>,
    {
        Pmaxsd(op0, op1).write_inst(self)
    }

    fn pmaxsw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaxsw<Op0, Op1>: WriteInst<Self>,
    {
        Pmaxsw(op0, op1).write_inst(self)
    }

    fn pmaxub<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaxub<Op0, Op1>: WriteInst<Self>,
    {
        Pmaxub(op0, op1).write_inst(self)
    }

    fn pmaxud<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaxud<Op0, Op1>: WriteInst<Self>,
    {
        Pmaxud(op0, op1).write_inst(self)
    }

    fn pmaxuw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmaxuw<Op0, Op1>: WriteInst<Self>,
    {
        Pmaxuw(op0, op1).write_inst(self)
    }

    fn pminsb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pminsb<Op0, Op1>: WriteInst<Self>,
    {
        Pminsb(op0, op1).write_inst(self)
    }

    fn pminsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pminsd<Op0, Op1>: WriteInst<Self>,
    {
        Pminsd(op0, op1).write_inst(self)
    }

    fn pminsw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pminsw<Op0, Op1>: WriteInst<Self>,
    {
        Pminsw(op0, op1).write_inst(self)
    }

    fn pminub<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pminub<Op0, Op1>: WriteInst<Self>,
    {
        Pminub(op0, op1).write_inst(self)
    }

    fn pminud<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pminud<Op0, Op1>: WriteInst<Self>,
    {
        Pminud(op0, op1).write_inst(self)
    }

    fn pminuw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pminuw<Op0, Op1>: WriteInst<Self>,
    {
        Pminuw(op0, op1).write_inst(self)
    }

    fn pmovmskb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovmskb<Op0, Op1>: WriteInst<Self>,
    {
        Pmovmskb(op0, op1).write_inst(self)
    }

    fn pmovsxbd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovsxbd<Op0, Op1>: WriteInst<Self>,
    {
        Pmovsxbd(op0, op1).write_inst(self)
    }

    fn pmovsxbq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovsxbq<Op0, Op1>: WriteInst<Self>,
    {
        Pmovsxbq(op0, op1).write_inst(self)
    }

    fn pmovsxbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovsxbw<Op0, Op1>: WriteInst<Self>,
    {
        Pmovsxbw(op0, op1).write_inst(self)
    }

    fn pmovsxdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovsxdq<Op0, Op1>: WriteInst<Self>,
    {
        Pmovsxdq(op0, op1).write_inst(self)
    }

    fn pmovsxwd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovsxwd<Op0, Op1>: WriteInst<Self>,
    {
        Pmovsxwd(op0, op1).write_inst(self)
    }

    fn pmovsxwq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovsxwq<Op0, Op1>: WriteInst<Self>,
    {
        Pmovsxwq(op0, op1).write_inst(self)
    }

    fn pmovzxbd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovzxbd<Op0, Op1>: WriteInst<Self>,
    {
        Pmovzxbd(op0, op1).write_inst(self)
    }

    fn pmovzxbq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovzxbq<Op0, Op1>: WriteInst<Self>,
    {
        Pmovzxbq(op0, op1).write_inst(self)
    }

    fn pmovzxbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovzxbw<Op0, Op1>: WriteInst<Self>,
    {
        Pmovzxbw(op0, op1).write_inst(self)
    }

    fn pmovzxdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovzxdq<Op0, Op1>: WriteInst<Self>,
    {
        Pmovzxdq(op0, op1).write_inst(self)
    }

    fn pmovzxwd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovzxwd<Op0, Op1>: WriteInst<Self>,
    {
        Pmovzxwd(op0, op1).write_inst(self)
    }

    fn pmovzxwq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmovzxwq<Op0, Op1>: WriteInst<Self>,
    {
        Pmovzxwq(op0, op1).write_inst(self)
    }

    fn pmuldq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmuldq<Op0, Op1>: WriteInst<Self>,
    {
        Pmuldq(op0, op1).write_inst(self)
    }

    fn pmulhuw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmulhuw<Op0, Op1>: WriteInst<Self>,
    {
        Pmulhuw(op0, op1).write_inst(self)
    }

    fn pmulhw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmulhw<Op0, Op1>: WriteInst<Self>,
    {
        Pmulhw(op0, op1).write_inst(self)
    }

    fn pmulld<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmulld<Op0, Op1>: WriteInst<Self>,
    {
        Pmulld(op0, op1).write_inst(self)
    }

    fn pmullw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmullw<Op0, Op1>: WriteInst<Self>,
    {
        Pmullw(op0, op1).write_inst(self)
    }

    fn pmuludq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pmuludq<Op0, Op1>: WriteInst<Self>,
    {
        Pmuludq(op0, op1).write_inst(self)
    }

    fn popcntl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Popcntl<Op0, Op1>: WriteInst<Self>,
    {
        Popcntl(op0, op1).write_inst(self)
    }

    fn popcntq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Popcntq<Op0, Op1>: WriteInst<Self>,
    {
        Popcntq(op0, op1).write_inst(self)
    }

    fn popcntw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Popcntw<Op0, Op1>: WriteInst<Self>,
    {
        Popcntw(op0, op1).write_inst(self)
    }

    fn popfq(&mut self) -> io::Result<()> {
        Popfq().write_inst(self)
    }

    fn popfw(&mut self) -> io::Result<()> {
        Popfw().write_inst(self)
    }

    fn popq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Popq<Op0>: WriteInst<Self>,
    {
        Popq(op0).write_inst(self)
    }

    fn popw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Popw<Op0>: WriteInst<Self>,
    {
        Popw(op0).write_inst(self)
    }

    fn por<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Por<Op0, Op1>: WriteInst<Self>,
    {
        Por(op0, op1).write_inst(self)
    }

    fn psadbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psadbw<Op0, Op1>: WriteInst<Self>,
    {
        Psadbw(op0, op1).write_inst(self)
    }

    fn pshufd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pshufd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pshufd(op0, op1, op2).write_inst(self)
    }

    fn pshufhw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pshufhw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pshufhw(op0, op1, op2).write_inst(self)
    }

    fn pshuflw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Pshuflw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Pshuflw(op0, op1, op2).write_inst(self)
    }

    fn pslld<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pslld<Op0, Op1>: WriteInst<Self>,
    {
        Pslld(op0, op1).write_inst(self)
    }

    fn pslldq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pslldq<Op0, Op1>: WriteInst<Self>,
    {
        Pslldq(op0, op1).write_inst(self)
    }

    fn psllq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psllq<Op0, Op1>: WriteInst<Self>,
    {
        Psllq(op0, op1).write_inst(self)
    }

    fn psllw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psllw<Op0, Op1>: WriteInst<Self>,
    {
        Psllw(op0, op1).write_inst(self)
    }

    fn psrad<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psrad<Op0, Op1>: WriteInst<Self>,
    {
        Psrad(op0, op1).write_inst(self)
    }

    fn psraw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psraw<Op0, Op1>: WriteInst<Self>,
    {
        Psraw(op0, op1).write_inst(self)
    }

    fn psrld<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psrld<Op0, Op1>: WriteInst<Self>,
    {
        Psrld(op0, op1).write_inst(self)
    }

    fn psrldq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psrldq<Op0, Op1>: WriteInst<Self>,
    {
        Psrldq(op0, op1).write_inst(self)
    }

    fn psrlq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psrlq<Op0, Op1>: WriteInst<Self>,
    {
        Psrlq(op0, op1).write_inst(self)
    }

    fn psrlw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psrlw<Op0, Op1>: WriteInst<Self>,
    {
        Psrlw(op0, op1).write_inst(self)
    }

    fn psubb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubb<Op0, Op1>: WriteInst<Self>,
    {
        Psubb(op0, op1).write_inst(self)
    }

    fn psubd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubd<Op0, Op1>: WriteInst<Self>,
    {
        Psubd(op0, op1).write_inst(self)
    }

    fn psubq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubq<Op0, Op1>: WriteInst<Self>,
    {
        Psubq(op0, op1).write_inst(self)
    }

    fn psubsb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubsb<Op0, Op1>: WriteInst<Self>,
    {
        Psubsb(op0, op1).write_inst(self)
    }

    fn psubsw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubsw<Op0, Op1>: WriteInst<Self>,
    {
        Psubsw(op0, op1).write_inst(self)
    }

    fn psubusb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubusb<Op0, Op1>: WriteInst<Self>,
    {
        Psubusb(op0, op1).write_inst(self)
    }

    fn psubusw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubusw<Op0, Op1>: WriteInst<Self>,
    {
        Psubusw(op0, op1).write_inst(self)
    }

    fn psubw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Psubw<Op0, Op1>: WriteInst<Self>,
    {
        Psubw(op0, op1).write_inst(self)
    }

    fn ptest<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Ptest<Op0, Op1>: WriteInst<Self>,
    {
        Ptest(op0, op1).write_inst(self)
    }

    fn punpckhbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpckhbw<Op0, Op1>: WriteInst<Self>,
    {
        Punpckhbw(op0, op1).write_inst(self)
    }

    fn punpckhdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpckhdq<Op0, Op1>: WriteInst<Self>,
    {
        Punpckhdq(op0, op1).write_inst(self)
    }

    fn punpckhqdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpckhqdq<Op0, Op1>: WriteInst<Self>,
    {
        Punpckhqdq(op0, op1).write_inst(self)
    }

    fn punpckhwd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpckhwd<Op0, Op1>: WriteInst<Self>,
    {
        Punpckhwd(op0, op1).write_inst(self)
    }

    fn punpcklbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpcklbw<Op0, Op1>: WriteInst<Self>,
    {
        Punpcklbw(op0, op1).write_inst(self)
    }

    fn punpckldq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpckldq<Op0, Op1>: WriteInst<Self>,
    {
        Punpckldq(op0, op1).write_inst(self)
    }

    fn punpcklqdq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpcklqdq<Op0, Op1>: WriteInst<Self>,
    {
        Punpcklqdq(op0, op1).write_inst(self)
    }

    fn punpcklwd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Punpcklwd<Op0, Op1>: WriteInst<Self>,
    {
        Punpcklwd(op0, op1).write_inst(self)
    }

    fn pushfq(&mut self) -> io::Result<()> {
        Pushfq().write_inst(self)
    }

    fn pushfw(&mut self) -> io::Result<()> {
        Pushfw().write_inst(self)
    }

    fn pushq<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Pushq<Op0>: WriteInst<Self>,
    {
        Pushq(op0).write_inst(self)
    }

    fn pushw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Pushw<Op0>: WriteInst<Self>,
    {
        Pushw(op0).write_inst(self)
    }

    fn pxor<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Pxor<Op0, Op1>: WriteInst<Self>,
    {
        Pxor(op0, op1).write_inst(self)
    }

    fn rclb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rclb<Op0, Op1>: WriteInst<Self>,
    {
        Rclb(op0, op1).write_inst(self)
    }

    fn rcll<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcll<Op0, Op1>: WriteInst<Self>,
    {
        Rcll(op0, op1).write_inst(self)
    }

    fn rclq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rclq<Op0, Op1>: WriteInst<Self>,
    {
        Rclq(op0, op1).write_inst(self)
    }

    fn rclw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rclw<Op0, Op1>: WriteInst<Self>,
    {
        Rclw(op0, op1).write_inst(self)
    }

    fn rcpps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcpps<Op0, Op1>: WriteInst<Self>,
    {
        Rcpps(op0, op1).write_inst(self)
    }

    fn rcpss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcpss<Op0, Op1>: WriteInst<Self>,
    {
        Rcpss(op0, op1).write_inst(self)
    }

    fn rcrb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcrb<Op0, Op1>: WriteInst<Self>,
    {
        Rcrb(op0, op1).write_inst(self)
    }

    fn rcrl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcrl<Op0, Op1>: WriteInst<Self>,
    {
        Rcrl(op0, op1).write_inst(self)
    }

    fn rcrq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcrq<Op0, Op1>: WriteInst<Self>,
    {
        Rcrq(op0, op1).write_inst(self)
    }

    fn rcrw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rcrw<Op0, Op1>: WriteInst<Self>,
    {
        Rcrw(op0, op1).write_inst(self)
    }

    fn retq(&mut self) -> io::Result<()> {
        Retq().write_inst(self)
    }

    fn retq1<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Retq1<Op0>: WriteInst<Self>,
    {
        Retq1(op0).write_inst(self)
    }

    fn rolb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rolb<Op0, Op1>: WriteInst<Self>,
    {
        Rolb(op0, op1).write_inst(self)
    }

    fn roll<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Roll<Op0, Op1>: WriteInst<Self>,
    {
        Roll(op0, op1).write_inst(self)
    }

    fn rolq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rolq<Op0, Op1>: WriteInst<Self>,
    {
        Rolq(op0, op1).write_inst(self)
    }

    fn rolw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rolw<Op0, Op1>: WriteInst<Self>,
    {
        Rolw(op0, op1).write_inst(self)
    }

    fn rorb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rorb<Op0, Op1>: WriteInst<Self>,
    {
        Rorb(op0, op1).write_inst(self)
    }

    fn rorl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rorl<Op0, Op1>: WriteInst<Self>,
    {
        Rorl(op0, op1).write_inst(self)
    }

    fn rorq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rorq<Op0, Op1>: WriteInst<Self>,
    {
        Rorq(op0, op1).write_inst(self)
    }

    fn rorw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rorw<Op0, Op1>: WriteInst<Self>,
    {
        Rorw(op0, op1).write_inst(self)
    }

    fn roundpd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Roundpd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Roundpd(op0, op1, op2).write_inst(self)
    }

    fn roundps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Roundps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Roundps(op0, op1, op2).write_inst(self)
    }

    fn roundsd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Roundsd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Roundsd(op0, op1, op2).write_inst(self)
    }

    fn roundss<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Roundss<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Roundss(op0, op1, op2).write_inst(self)
    }

    fn rsqrtps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rsqrtps<Op0, Op1>: WriteInst<Self>,
    {
        Rsqrtps(op0, op1).write_inst(self)
    }

    fn rsqrtss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Rsqrtss<Op0, Op1>: WriteInst<Self>,
    {
        Rsqrtss(op0, op1).write_inst(self)
    }

    fn salb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Salb<Op0, Op1>: WriteInst<Self>,
    {
        Salb(op0, op1).write_inst(self)
    }

    fn sall<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sall<Op0, Op1>: WriteInst<Self>,
    {
        Sall(op0, op1).write_inst(self)
    }

    fn salq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Salq<Op0, Op1>: WriteInst<Self>,
    {
        Salq(op0, op1).write_inst(self)
    }

    fn salw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Salw<Op0, Op1>: WriteInst<Self>,
    {
        Salw(op0, op1).write_inst(self)
    }

    fn sarb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sarb<Op0, Op1>: WriteInst<Self>,
    {
        Sarb(op0, op1).write_inst(self)
    }

    fn sarl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sarl<Op0, Op1>: WriteInst<Self>,
    {
        Sarl(op0, op1).write_inst(self)
    }

    fn sarq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sarq<Op0, Op1>: WriteInst<Self>,
    {
        Sarq(op0, op1).write_inst(self)
    }

    fn sarw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sarw<Op0, Op1>: WriteInst<Self>,
    {
        Sarw(op0, op1).write_inst(self)
    }

    fn sbbb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sbbb<Op0, Op1>: WriteInst<Self>,
    {
        Sbbb(op0, op1).write_inst(self)
    }

    fn sbbl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sbbl<Op0, Op1>: WriteInst<Self>,
    {
        Sbbl(op0, op1).write_inst(self)
    }

    fn sbbq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sbbq<Op0, Op1>: WriteInst<Self>,
    {
        Sbbq(op0, op1).write_inst(self)
    }

    fn sbbw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sbbw<Op0, Op1>: WriteInst<Self>,
    {
        Sbbw(op0, op1).write_inst(self)
    }

    fn seta<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Seta<Op0>: WriteInst<Self>,
    {
        Seta(op0).write_inst(self)
    }

    fn setae<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setae<Op0>: WriteInst<Self>,
    {
        Setae(op0).write_inst(self)
    }

    fn setb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setb<Op0>: WriteInst<Self>,
    {
        Setb(op0).write_inst(self)
    }

    fn setbe<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setbe<Op0>: WriteInst<Self>,
    {
        Setbe(op0).write_inst(self)
    }

    fn setc<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setc<Op0>: WriteInst<Self>,
    {
        Setc(op0).write_inst(self)
    }

    fn sete<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Sete<Op0>: WriteInst<Self>,
    {
        Sete(op0).write_inst(self)
    }

    fn setg<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setg<Op0>: WriteInst<Self>,
    {
        Setg(op0).write_inst(self)
    }

    fn setge<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setge<Op0>: WriteInst<Self>,
    {
        Setge(op0).write_inst(self)
    }

    fn setl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setl<Op0>: WriteInst<Self>,
    {
        Setl(op0).write_inst(self)
    }

    fn setle<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setle<Op0>: WriteInst<Self>,
    {
        Setle(op0).write_inst(self)
    }

    fn setna<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setna<Op0>: WriteInst<Self>,
    {
        Setna(op0).write_inst(self)
    }

    fn setnae<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnae<Op0>: WriteInst<Self>,
    {
        Setnae(op0).write_inst(self)
    }

    fn setnb<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnb<Op0>: WriteInst<Self>,
    {
        Setnb(op0).write_inst(self)
    }

    fn setnbe<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnbe<Op0>: WriteInst<Self>,
    {
        Setnbe(op0).write_inst(self)
    }

    fn setnc<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnc<Op0>: WriteInst<Self>,
    {
        Setnc(op0).write_inst(self)
    }

    fn setne<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setne<Op0>: WriteInst<Self>,
    {
        Setne(op0).write_inst(self)
    }

    fn setng<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setng<Op0>: WriteInst<Self>,
    {
        Setng(op0).write_inst(self)
    }

    fn setnge<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnge<Op0>: WriteInst<Self>,
    {
        Setnge(op0).write_inst(self)
    }

    fn setnl<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnl<Op0>: WriteInst<Self>,
    {
        Setnl(op0).write_inst(self)
    }

    fn setnle<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnle<Op0>: WriteInst<Self>,
    {
        Setnle(op0).write_inst(self)
    }

    fn setno<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setno<Op0>: WriteInst<Self>,
    {
        Setno(op0).write_inst(self)
    }

    fn setnp<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnp<Op0>: WriteInst<Self>,
    {
        Setnp(op0).write_inst(self)
    }

    fn setns<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setns<Op0>: WriteInst<Self>,
    {
        Setns(op0).write_inst(self)
    }

    fn setnz<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setnz<Op0>: WriteInst<Self>,
    {
        Setnz(op0).write_inst(self)
    }

    fn seto<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Seto<Op0>: WriteInst<Self>,
    {
        Seto(op0).write_inst(self)
    }

    fn setp<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setp<Op0>: WriteInst<Self>,
    {
        Setp(op0).write_inst(self)
    }

    fn setpe<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setpe<Op0>: WriteInst<Self>,
    {
        Setpe(op0).write_inst(self)
    }

    fn setpo<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setpo<Op0>: WriteInst<Self>,
    {
        Setpo(op0).write_inst(self)
    }

    fn sets<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Sets<Op0>: WriteInst<Self>,
    {
        Sets(op0).write_inst(self)
    }

    fn setz<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Setz<Op0>: WriteInst<Self>,
    {
        Setz(op0).write_inst(self)
    }

    fn sfence(&mut self) -> io::Result<()> {
        Sfence().write_inst(self)
    }

    fn sgdt<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Sgdt<Op0>: WriteInst<Self>,
    {
        Sgdt(op0).write_inst(self)
    }

    fn shlb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shlb<Op0, Op1>: WriteInst<Self>,
    {
        Shlb(op0, op1).write_inst(self)
    }

    fn shldl<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shldl<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shldl(op0, op1, op2).write_inst(self)
    }

    fn shldq<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shldq<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shldq(op0, op1, op2).write_inst(self)
    }

    fn shldw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shldw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shldw(op0, op1, op2).write_inst(self)
    }

    fn shll<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shll<Op0, Op1>: WriteInst<Self>,
    {
        Shll(op0, op1).write_inst(self)
    }

    fn shlq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shlq<Op0, Op1>: WriteInst<Self>,
    {
        Shlq(op0, op1).write_inst(self)
    }

    fn shlw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shlw<Op0, Op1>: WriteInst<Self>,
    {
        Shlw(op0, op1).write_inst(self)
    }

    fn shrb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shrb<Op0, Op1>: WriteInst<Self>,
    {
        Shrb(op0, op1).write_inst(self)
    }

    fn shrdl<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shrdl<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shrdl(op0, op1, op2).write_inst(self)
    }

    fn shrdq<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shrdq<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shrdq(op0, op1, op2).write_inst(self)
    }

    fn shrdw<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shrdw<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shrdw(op0, op1, op2).write_inst(self)
    }

    fn shrl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shrl<Op0, Op1>: WriteInst<Self>,
    {
        Shrl(op0, op1).write_inst(self)
    }

    fn shrq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shrq<Op0, Op1>: WriteInst<Self>,
    {
        Shrq(op0, op1).write_inst(self)
    }

    fn shrw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Shrw<Op0, Op1>: WriteInst<Self>,
    {
        Shrw(op0, op1).write_inst(self)
    }

    fn shufpd<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shufpd<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shufpd(op0, op1, op2).write_inst(self)
    }

    fn shufps<Op0, Op1, Op2>(&mut self, op0: Op0, op1: Op1, op2: Op2) -> io::Result<()>
    where
        Shufps<Op0, Op1, Op2>: WriteInst<Self>,
    {
        Shufps(op0, op1, op2).write_inst(self)
    }

    fn sidt<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Sidt<Op0>: WriteInst<Self>,
    {
        Sidt(op0).write_inst(self)
    }

    fn sqrtpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sqrtpd<Op0, Op1>: WriteInst<Self>,
    {
        Sqrtpd(op0, op1).write_inst(self)
    }

    fn sqrtps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sqrtps<Op0, Op1>: WriteInst<Self>,
    {
        Sqrtps(op0, op1).write_inst(self)
    }

    fn sqrtsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sqrtsd<Op0, Op1>: WriteInst<Self>,
    {
        Sqrtsd(op0, op1).write_inst(self)
    }

    fn sqrtss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Sqrtss<Op0, Op1>: WriteInst<Self>,
    {
        Sqrtss(op0, op1).write_inst(self)
    }

    fn stc(&mut self) -> io::Result<()> {
        Stc().write_inst(self)
    }

    fn std(&mut self) -> io::Result<()> {
        Std().write_inst(self)
    }

    fn sti(&mut self) -> io::Result<()> {
        Sti().write_inst(self)
    }

    fn stmxcsr<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Stmxcsr<Op0>: WriteInst<Self>,
    {
        Stmxcsr(op0).write_inst(self)
    }

    fn str<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Str<Op0>: WriteInst<Self>,
    {
        Str(op0).write_inst(self)
    }

    fn subb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subb<Op0, Op1>: WriteInst<Self>,
    {
        Subb(op0, op1).write_inst(self)
    }

    fn subl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subl<Op0, Op1>: WriteInst<Self>,
    {
        Subl(op0, op1).write_inst(self)
    }

    fn subpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subpd<Op0, Op1>: WriteInst<Self>,
    {
        Subpd(op0, op1).write_inst(self)
    }

    fn subps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subps<Op0, Op1>: WriteInst<Self>,
    {
        Subps(op0, op1).write_inst(self)
    }

    fn subq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subq<Op0, Op1>: WriteInst<Self>,
    {
        Subq(op0, op1).write_inst(self)
    }

    fn subsd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subsd<Op0, Op1>: WriteInst<Self>,
    {
        Subsd(op0, op1).write_inst(self)
    }

    fn subss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subss<Op0, Op1>: WriteInst<Self>,
    {
        Subss(op0, op1).write_inst(self)
    }

    fn subw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Subw<Op0, Op1>: WriteInst<Self>,
    {
        Subw(op0, op1).write_inst(self)
    }

    fn swapgs(&mut self) -> io::Result<()> {
        Swapgs().write_inst(self)
    }

    fn testb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Testb<Op0, Op1>: WriteInst<Self>,
    {
        Testb(op0, op1).write_inst(self)
    }

    fn testl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Testl<Op0, Op1>: WriteInst<Self>,
    {
        Testl(op0, op1).write_inst(self)
    }

    fn testq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Testq<Op0, Op1>: WriteInst<Self>,
    {
        Testq(op0, op1).write_inst(self)
    }

    fn testw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Testw<Op0, Op1>: WriteInst<Self>,
    {
        Testw(op0, op1).write_inst(self)
    }

    fn ucomisd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Ucomisd<Op0, Op1>: WriteInst<Self>,
    {
        Ucomisd(op0, op1).write_inst(self)
    }

    fn ucomiss<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Ucomiss<Op0, Op1>: WriteInst<Self>,
    {
        Ucomiss(op0, op1).write_inst(self)
    }

    fn ud2(&mut self) -> io::Result<()> {
        Ud2().write_inst(self)
    }

    fn unpckhpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Unpckhpd<Op0, Op1>: WriteInst<Self>,
    {
        Unpckhpd(op0, op1).write_inst(self)
    }

    fn unpckhps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Unpckhps<Op0, Op1>: WriteInst<Self>,
    {
        Unpckhps(op0, op1).write_inst(self)
    }

    fn unpcklpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Unpcklpd<Op0, Op1>: WriteInst<Self>,
    {
        Unpcklpd(op0, op1).write_inst(self)
    }

    fn unpcklps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Unpcklps<Op0, Op1>: WriteInst<Self>,
    {
        Unpcklps(op0, op1).write_inst(self)
    }

    fn verr<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Verr<Op0>: WriteInst<Self>,
    {
        Verr(op0).write_inst(self)
    }

    fn verw<Op0>(&mut self, op0: Op0) -> io::Result<()>
    where
        Verw<Op0>: WriteInst<Self>,
    {
        Verw(op0).write_inst(self)
    }

    fn wbinvd(&mut self) -> io::Result<()> {
        Wbinvd().write_inst(self)
    }

    fn wrmsr(&mut self) -> io::Result<()> {
        Wrmsr().write_inst(self)
    }

    fn xaddb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xaddb<Op0, Op1>: WriteInst<Self>,
    {
        Xaddb(op0, op1).write_inst(self)
    }

    fn xaddl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xaddl<Op0, Op1>: WriteInst<Self>,
    {
        Xaddl(op0, op1).write_inst(self)
    }

    fn xaddq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xaddq<Op0, Op1>: WriteInst<Self>,
    {
        Xaddq(op0, op1).write_inst(self)
    }

    fn xaddw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xaddw<Op0, Op1>: WriteInst<Self>,
    {
        Xaddw(op0, op1).write_inst(self)
    }

    fn xchgb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xchgb<Op0, Op1>: WriteInst<Self>,
    {
        Xchgb(op0, op1).write_inst(self)
    }

    fn xchgl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xchgl<Op0, Op1>: WriteInst<Self>,
    {
        Xchgl(op0, op1).write_inst(self)
    }

    fn xchgq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xchgq<Op0, Op1>: WriteInst<Self>,
    {
        Xchgq(op0, op1).write_inst(self)
    }

    fn xchgw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xchgw<Op0, Op1>: WriteInst<Self>,
    {
        Xchgw(op0, op1).write_inst(self)
    }

    fn xorb<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xorb<Op0, Op1>: WriteInst<Self>,
    {
        Xorb(op0, op1).write_inst(self)
    }

    fn xorl<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xorl<Op0, Op1>: WriteInst<Self>,
    {
        Xorl(op0, op1).write_inst(self)
    }

    fn xorpd<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xorpd<Op0, Op1>: WriteInst<Self>,
    {
        Xorpd(op0, op1).write_inst(self)
    }

    fn xorps<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xorps<Op0, Op1>: WriteInst<Self>,
    {
        Xorps(op0, op1).write_inst(self)
    }

    fn xorq<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xorq<Op0, Op1>: WriteInst<Self>,
    {
        Xorq(op0, op1).write_inst(self)
    }

    fn xorw<Op0, Op1>(&mut self, op0: Op0, op1: Op1) -> io::Result<()>
    where
        Xorw<Op0, Op1>: WriteInst<Self>,
    {
        Xorw(op0, op1).write_inst(self)
    }

    fn xsetbv(&mut self) -> io::Result<()> {
        Xsetbv().write_inst(self)
    }
}

impl<W: io::Write + ?Sized> WriteInstExt for W {}

pub trait WriteInst<W: ?Sized> {
    fn write_inst(&self, w: &mut W) -> io::Result<()>;
}

pub struct Adcb<Op0, Op1>(pub Op0, pub Op1);

/// adcb r8 r8: Add with carry r/m8 to byte register.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 12 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x12)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcb r8 m8: Add with carry r/m8 to byte register.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 12 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x12)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcb m8 r8: Add with carry byte register to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 10 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcb r8 imm8: Add with carry imm8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcb m8 imm8: Add with carry imm8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcb _Al imm8: Add with carry imm8 to AL
impl<W: io::Write + ?Sized> WriteInst<W> for Adcb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 14 ib
        put(w, 0x14)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Adcl<Op0, Op1>(pub Op0, pub Op1);

/// adcl r32 r32: Add with CF r/m32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 13 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcl r32 m32: Add with CF r/m32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 13 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcl m32 r32: Add with CF r32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 11 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcl r32 imm8: Add with CF sign-extended imm8 into r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcl m32 imm8: Add with CF sign-extended imm8 into r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcl r32 imm32: Add with CF imm32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /2 id
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcl m32 imm32: Add with CF imm32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /2 id
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcl _Eax imm32: Add with carry imm32 to EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 15 id
        put(w, 0x15)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Adcq<Op0, Op1>(pub Op0, pub Op1);

/// adcq r64 r64: Add with CF r/m64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 13 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcq r64 m64: Add with CF r/m64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 13 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcq m64 r64: Add with CF r64 to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 11 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcq r64 imm8: Add with CF sign-extended imm8 into r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcq m64 imm8: Add with CF sign-extended imm8 into r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcq r64 imm32: Add with CF imm32 sign extended to 64-bits to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /2 id
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcq m64 imm32: Add with CF imm32 sign extended to 64-bits to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /2 id
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcq _Rax imm32: Add with carry imm32 sign extended to 64- bits to RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 15 id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x15)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Adcw<Op0, Op1>(pub Op0, pub Op1);

/// adcw r16 r16: Add with carry r/m16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 13 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcw r16 m16: Add with carry r/m16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 13 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcw m16 r16: Add with carry r16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 11 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// adcw r16 imm8: Add with CF sign-extended imm8 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcw m16 imm8: Add with CF sign-extended imm8 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcw r16 imm16: Add with carry imm16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /2 iw
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcw m16 imm16: Add with carry imm16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /2 iw
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// adcw _Ax imm16: Add with carry imm16 to AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Adcw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 15 iw
        put(w, 0x66)?;
        put(w, 0x15)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Addb<Op0, Op1>(pub Op0, pub Op1);

/// addb r8 r8: Add r/m8 to r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Addb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 02 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x02)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addb r8 m8: Add r/m8 to r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Addb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 02 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x02)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addb m8 r8: Add r8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Addb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 00 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addb r8 imm8: Add imm8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Addb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addb m8 imm8: Add imm8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Addb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addb _Al imm8: Add imm8 to AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Addb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 04 ib
        put(w, 0x04)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Addl<Op0, Op1>(pub Op0, pub Op1);

/// addl r32 r32: Add r/m32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 03 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x03)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addl r32 m32: Add r/m32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 03 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x03)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addl m32 r32: Add r32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 01 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addl r32 imm8: Add sign-extended imm8 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addl m32 imm8: Add sign-extended imm8 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addl r32 imm32: Add imm32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addl m32 imm32: Add imm32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addl _Eax imm32: Add imm32 to EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Addl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 05 id
        put(w, 0x05)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Addpd<Op0, Op1>(pub Op0, pub Op1);

/// addpd xmm xmm: Add packed double-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addpd xmm m128: Add packed double-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Addps<Op0, Op1>(pub Op0, pub Op1);

/// addps xmm xmm: Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addps xmm m128: Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Addq<Op0, Op1>(pub Op0, pub Op1);

/// addq r64 r64: Add r/m64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 03 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x03)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addq r64 m64: Add r/m64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 03 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x03)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addq m64 r64: Add r64 to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 01 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addq r64 imm8: Add sign-extended imm8 to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addq m64 imm8: Add sign-extended imm8 to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addq r64 imm32: Add imm32 sign-extended to 64-bits to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addq m64 imm32: Add imm32 sign-extended to 64-bits to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addq _Rax imm32: Add imm32 sign-extended to 64-bits to RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Addq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 05 id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x05)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Addsd<Op0, Op1>(pub Op0, pub Op1);

/// addsd xmm xmm: Add the low double-precision floating-point value from xmm2/m64 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addsd xmm m64: Add the low double-precision floating-point value from xmm2/m64 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Addss<Op0, Op1>(pub Op0, pub Op1);

/// addss xmm xmm: Add the low single-precision floating-point value from xmm2/m32 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addss xmm m32: Add the low single-precision floating-point value from xmm2/m32 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Addss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 58 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x58)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Addw<Op0, Op1>(pub Op0, pub Op1);

/// addw r16 r16: Add r/m16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 03 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x03)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addw r16 m16: Add r/m16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 03 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x03)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addw m16 r16: Add r16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 01 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// addw r16 imm8: Add sign-extended imm8 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addw m16 imm8: Add sign-extended imm8 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addw r16 imm16: Add imm16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /0 iw
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addw m16 imm16: Add imm16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /0 iw
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// addw _Ax imm16: Add imm16 to AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Addw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 05 iw
        put(w, 0x66)?;
        put(w, 0x05)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Andb<Op0, Op1>(pub Op0, pub Op1);

/// andb r8 r8: r8 AND r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Andb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 22 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x22)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andb r8 m8: r8 AND r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Andb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 22 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x22)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andb m8 r8: r/m8 AND r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Andb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 20 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x20)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andb r8 imm8: r/m8 AND imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Andb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andb m8 imm8: r/m8 AND imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Andb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andb _Al imm8: AL AND imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Andb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 24 ib
        put(w, 0x24)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Andl<Op0, Op1>(pub Op0, pub Op1);

/// andl r32 r32: r32 AND r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 23 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andl r32 m32: r32 AND r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 23 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andl m32 r32: r/m32 AND r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 21 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andl r32 imm8: r/m32 AND imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andl m32 imm8: r/m32 AND imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andl r32 imm32: r/m32 AND imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /4 id
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andl m32 imm32: r/m32 AND imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /4 id
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andl _Eax imm32: EAX AND imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 25 id
        put(w, 0x25)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Andnpd<Op0, Op1>(pub Op0, pub Op1);

/// andnpd xmm xmm: Bitwise logical AND NOT of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Andnpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 55 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x55)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andnpd xmm m128: Bitwise logical AND NOT of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Andnpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 55 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x55)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Andnps<Op0, Op1>(pub Op0, pub Op1);

/// andnps xmm xmm: Bitwise logical AND NOT of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Andnps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 55 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x55)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andnps xmm m128: Bitwise logical AND NOT of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Andnps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 55 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x55)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Andpd<Op0, Op1>(pub Op0, pub Op1);

/// andpd xmm xmm: Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Andpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 54 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x54)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andpd xmm m128: Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Andpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 54 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x54)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Andps<Op0, Op1>(pub Op0, pub Op1);

/// andps xmm xmm: Bitwise logical AND of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Andps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 54 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x54)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andps xmm m128: Bitwise logical AND of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Andps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 54 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x54)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Andq<Op0, Op1>(pub Op0, pub Op1);

/// andq r64 r64: r64 AND r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 23 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andq r64 m64: r64 AND r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 23 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andq m64 r64: r/m64 AND r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 21 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andq r64 imm8: r/m64 AND imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andq m64 imm8: r/m64 AND imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andq r64 imm32: r/m64 AND imm32 sign extended to 64-bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /4 id
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andq m64 imm32: r/m64 AND imm32 sign extended to 64-bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /4 id
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andq _Rax imm32: RAX AND imm32 sign-extended to 64-bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Andq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 25 id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x25)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Andw<Op0, Op1>(pub Op0, pub Op1);

/// andw r16 r16: r16 AND r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 23 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andw r16 m16: r16 AND r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 23 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andw m16 r16: r/m16 AND r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 21 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// andw r16 imm8: r/m16 AND imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andw m16 imm8: r/m16 AND imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andw r16 imm16: r/m16 AND imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /4 iw
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andw m16 imm16: r/m16 AND imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /4 iw
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// andw _Ax imm16: AX AND imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Andw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 25 iw
        put(w, 0x66)?;
        put(w, 0x25)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Blendpd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// blendpd xmm xmm imm8: Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendpd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0D /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// blendpd xmm m128 imm8: Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendpd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0D /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Blendps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// blendps xmm xmm imm8: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendps<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0C /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// blendps xmm m128 imm8: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendps<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0C /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Blendvpd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// blendvpd xmm xmm _Xmm0: Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendvpd<Xmm, Xmm, _Xmm0> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 15 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// blendvpd xmm m128 _Xmm0: Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendvpd<Xmm, Memory, _Xmm0> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 15 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Blendvps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// blendvps xmm xmm _Xmm0: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendvps<Xmm, Xmm, _Xmm0> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 14 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// blendvps xmm m128 _Xmm0: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Blendvps<Xmm, Memory, _Xmm0> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 14 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bsfl<Op0, Op1>(pub Op0, pub Op1);

/// bsfl r32 r32: Bit scan forward on r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsfl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BC /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// bsfl r32 m32: Bit scan forward on r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsfl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BC /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bsfq<Op0, Op1>(pub Op0, pub Op1);

/// bsfq r64 r64: Bit scan forward on r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsfq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BC /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// bsfq r64 m64: Bit scan forward on r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsfq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BC /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bsfw<Op0, Op1>(pub Op0, pub Op1);

/// bsfw r16 r16: Bit scan forward on r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsfw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// bsfw r16 m16: Bit scan forward on r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsfw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bsrl<Op0, Op1>(pub Op0, pub Op1);

/// bsrl r32 r32: Bit scan reverse on r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsrl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BD /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// bsrl r32 m32: Bit scan reverse on r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsrl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BD /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bsrq<Op0, Op1>(pub Op0, pub Op1);

/// bsrq r64 r64: Bit scan reverse on r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsrq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BD /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// bsrq r64 m64: Bit scan reverse on r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsrq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BD /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bsrw<Op0, Op1>(pub Op0, pub Op1);

/// bsrw r16 r16: Bit scan reverse on r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsrw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BD /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// bsrw r16 m16: Bit scan reverse on r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Bsrw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BD /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Bswap<Op0>(pub Op0);

/// bswap r32: Reverses the byte order of a 32-bit register.
impl<W: io::Write + ?Sized> WriteInst<W> for Bswap<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C8 +rd
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC8 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// bswap r64: Reverses the byte order of a 64-bit register.
impl<W: io::Write + ?Sized> WriteInst<W> for Bswap<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F C8 +ro
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xC8 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

pub struct Btcl<Op0, Op1>(pub Op0, pub Op1);

/// btcl r32 r32: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btcl m32 r32: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btcl r32 imm8: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btcl m32 imm8: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btcq<Op0, Op1>(pub Op0, pub Op1);

/// btcq r64 r64: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btcq m64 r64: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btcq r64 imm8: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btcq m64 imm8: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btcw<Op0, Op1>(pub Op0, pub Op1);

/// btcw r16 r16: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BB /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btcw m16 r16: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BB /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btcw r16 imm8: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btcw m16 imm8: Store selected bit in CF flag and complement.
impl<W: io::Write + ?Sized> WriteInst<W> for Btcw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btl<Op0, Op1>(pub Op0, pub Op1);

/// btl r32 r32: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btl m32 r32: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btl r32 imm8: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btl m32 imm8: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btq<Op0, Op1>(pub Op0, pub Op1);

/// btq r64 r64: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F A3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xA3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btq m64 r64: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F A3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xA3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btq r64 imm8: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btq m64 imm8: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btrl<Op0, Op1>(pub Op0, pub Op1);

/// btrl r32 r32: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btrl m32 r32: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btrl r32 imm8: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btrl m32 imm8: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btrq<Op0, Op1>(pub Op0, pub Op1);

/// btrq r64 r64: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btrq m64 r64: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btrq r64 imm8: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btrq m64 imm8: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btrw<Op0, Op1>(pub Op0, pub Op1);

/// btrw r16 r16: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F B3 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btrw m16 r16: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F B3 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btrw r16 imm8: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btrw m16 imm8: Store selected bit in CF flag and clear.
impl<W: io::Write + ?Sized> WriteInst<W> for Btrw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btsl<Op0, Op1>(pub Op0, pub Op1);

/// btsl r32 r32: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btsl m32 r32: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btsl r32 imm8: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btsl m32 imm8: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BA /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btsq<Op0, Op1>(pub Op0, pub Op1);

/// btsq r64 r64: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btsq m64 r64: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AB /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btsq r64 imm8: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btsq m64 imm8: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BA /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btsw<Op0, Op1>(pub Op0, pub Op1);

/// btsw r16 r16: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AB /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btsw m16 r16: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AB /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btsw r16 imm8: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btsw m16 imm8: Store selected bit in CF flag and set.
impl<W: io::Write + ?Sized> WriteInst<W> for Btsw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Btw<Op0, Op1>(pub Op0, pub Op1);

/// btw r16 r16: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F A3 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btw m16 r16: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F A3 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// btw r16 imm8: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// btw m16 imm8: Store selected bit in CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Btw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BA /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Callq<Op0>(pub Op0);

/// callq rel32: Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.
impl<W: io::Write + ?Sized> WriteInst<W> for Callq<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E8 cd
        put(w, 0xE8)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// callq r64: Call near, absolute indirect, address given in r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Callq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// callq m64: Call near, absolute indirect, address given in r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Callq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cbtw();

/// cbtw: AX = sign-extend of AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Cbtw {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 98
        put(w, 0x66)?;
        put(w, 0x98)?;
        Ok(())
    }
}

pub struct Clc();

/// clc: Clear CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Clc {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F8
        put(w, 0xF8)?;
        Ok(())
    }
}

pub struct Cld();

/// cld: Clear DF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Cld {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FC
        put(w, 0xFC)?;
        Ok(())
    }
}

pub struct Cli();

/// cli: Clear interrupt flag; interrupts disabled when interrupt flag cleared.
impl<W: io::Write + ?Sized> WriteInst<W> for Cli {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FA
        put(w, 0xFA)?;
        Ok(())
    }
}

pub struct Cltd();

/// cltd: EDX:EAX = sign-extend of EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cltd {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 99
        put(w, 0x99)?;
        Ok(())
    }
}

pub struct Cltq();

/// cltq: RAX = sign-extend of EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cltq {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 98
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x98)?;
        Ok(())
    }
}

pub struct Clts();

/// clts: Clears TS flag in CR0.
impl<W: io::Write + ?Sized> WriteInst<W> for Clts {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 06
        put(w, 0x0F)?;
        put(w, 0x06)?;
        Ok(())
    }
}

pub struct Cmc();

/// cmc: Complement CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmc {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F5
        put(w, 0xF5)?;
        Ok(())
    }
}

pub struct Cmpb<Op0, Op1>(pub Op0, pub Op1);

/// cmpb r8 r8: Compare r/m8 with r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 3A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x3A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpb r8 m8: Compare r/m8 with r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 3A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x3A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpb m8 r8: Compare r8 with r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 38 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x38)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpb r8 imm8: Compare imm8 with r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpb m8 imm8: Compare imm8 with r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpb _Al imm8: Compare imm8 with AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 3C ib
        put(w, 0x3C)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpl<Op0, Op1>(pub Op0, pub Op1);

/// cmpl r32 r32: Compare r/m32 with r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 3B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpl r32 m32: Compare r/m32 with r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 3B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpl m32 r32: Compare r32 with r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 39 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x39)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpl r32 imm8: Compare imm8 with r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpl m32 imm8: Compare imm8 with r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpl r32 imm32: Compare imm32 with r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /7 id
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpl m32 imm32: Compare imm32 with r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /7 id
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpl _Eax imm32: Compare imm32 with EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 3D id
        put(w, 0x3D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmppd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// cmppd xmm xmm imm8: Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmppd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// cmppd xmm m128 imm8: Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmppd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// cmpps xmm xmm imm8: Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpps<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// cmpps xmm m128 imm8: Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpps<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpq<Op0, Op1>(pub Op0, pub Op1);

/// cmpq r64 r64: Compare r/m64 with r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 3B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpq r64 m64: Compare r/m64 with r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 3B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpq m64 r64: Compare r64 with r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 39 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x39)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpq r64 imm8: Compare imm8 with r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpq m64 imm8: Compare imm8 with r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpq r64 imm32: Compare imm32 sign-extended to 64-bits with r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /7 id
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpq m64 imm32: Compare imm32 sign-extended to 64-bits with r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /7 id
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpq _Rax imm32: Compare imm32 sign-extended to 64-bits with RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 3D id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x3D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpsd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// cmpsd xmm xmm imm8: Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpsd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// cmpsd xmm m64 imm8: Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpsd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpsl();

/// cmpsl: For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpsl {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // A7
        put(w, 0xA7)?;
        Ok(())
    }
}

pub struct Cmpss<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// cmpss xmm xmm imm8: Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpss<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// cmpss xmm m32 imm8: Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpss<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F C2 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpw<Op0, Op1>(pub Op0, pub Op1);

/// cmpw r16 r16: Compare r/m16 with r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 3B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpw r16 m16: Compare r/m16 with r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 3B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpw m16 r16: Compare r16 with r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 39 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x39)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpw r16 imm8: Compare imm8 with r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpw m16 imm8: Compare imm8 with r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpw r16 imm16: Compare imm16 with r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /7 iw
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpw m16 imm16: Compare imm16 with r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /7 iw
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// cmpw _Ax imm16: Compare imm16 with AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 3D iw
        put(w, 0x66)?;
        put(w, 0x3D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Cmpxchgb<Op0, Op1>(pub Op0, pub Op1);

/// cmpxchgb r8 r8: Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B0 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpxchgb m8 r8: Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B0 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cmpxchgl<Op0, Op1>(pub Op0, pub Op1);

/// cmpxchgl r32 r32: Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpxchgl m32 r32: Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cmpxchgq<Op0, Op1>(pub Op0, pub Op1);

/// cmpxchgq r64 r64: Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpxchgq m64 r64: Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cmpxchgw<Op0, Op1>(pub Op0, pub Op1);

/// cmpxchgw r16 r16: Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F B1 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cmpxchgw m16 r16: Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cmpxchgw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F B1 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Comisd<Op0, Op1>(pub Op0, pub Op1);

/// comisd xmm xmm: Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Comisd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 2F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// comisd xmm m64: Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Comisd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 2F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Comiss<Op0, Op1>(pub Op0, pub Op1);

/// comiss xmm xmm: Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Comiss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 2F /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// comiss xmm m32: Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Comiss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 2F /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cpuid();

/// cpuid: Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
impl<W: io::Write + ?Sized> WriteInst<W> for Cpuid {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A2
        put(w, 0x0F)?;
        put(w, 0xA2)?;
        Ok(())
    }
}

pub struct Cqto();

/// cqto: RDX:RAX = sign-extend of RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cqto {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 99
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x99)?;
        Ok(())
    }
}

pub struct Crc32b<Op0, Op1>(pub Op0, pub Op1);

/// crc32b r32 r8: Accumulate CRC32 on r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32b<Gpr32, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 38 F0 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// crc32b r32 m8: Accumulate CRC32 on r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32b<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 38 F0 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// crc32b r64 r8: Accumulate CRC32 on r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32b<Gpr64, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 38 F0 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// crc32b r64 m8: Accumulate CRC32 on r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32b<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 38 F0 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Crc32l<Op0, Op1>(pub Op0, pub Op1);

/// crc32l r32 r32: Accumulate CRC32 on r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32l<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 38 F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// crc32l r32 m32: Accumulate CRC32 on r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32l<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 38 F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Crc32q<Op0, Op1>(pub Op0, pub Op1);

/// crc32q r64 r64: Accumulate CRC32 on r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32q<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 38 F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// crc32q r64 m64: Accumulate CRC32 on r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32q<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 38 F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Crc32w<Op0, Op1>(pub Op0, pub Op1);

/// crc32w r32 r16: Accumulate CRC32 on r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32w<Gpr32, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 66 0F 38 F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// crc32w r32 m16: Accumulate CRC32 on r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Crc32w<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 66 0F 38 F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtdq2pd<Op0, Op1>(pub Op0, pub Op1);

/// cvtdq2pd xmm xmm: Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtdq2pd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F E6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtdq2pd xmm m64: Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtdq2pd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F E6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtdq2ps<Op0, Op1>(pub Op0, pub Op1);

/// cvtdq2ps xmm xmm: Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtdq2ps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtdq2ps xmm m128: Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtdq2ps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtpd2dq<Op0, Op1>(pub Op0, pub Op1);

/// cvtpd2dq xmm xmm: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtpd2dq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F E6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtpd2dq xmm m128: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtpd2dq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F E6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtpd2ps<Op0, Op1>(pub Op0, pub Op1);

/// cvtpd2ps xmm xmm: Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtpd2ps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtpd2ps xmm m128: Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtpd2ps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtps2dq<Op0, Op1>(pub Op0, pub Op1);

/// cvtps2dq xmm xmm: Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtps2dq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtps2dq xmm m128: Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtps2dq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtps2pd<Op0, Op1>(pub Op0, pub Op1);

/// cvtps2pd xmm xmm: Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtps2pd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtps2pd xmm m64: Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtps2pd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtsd2si<Op0, Op1>(pub Op0, pub Op1);

/// cvtsd2si r32 xmm: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsd2si<Gpr32, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsd2si r32 m64: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsd2si<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsd2si r64 xmm: Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsd2si<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsd2si r64 m64: Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsd2si<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtsd2ss<Op0, Op1>(pub Op0, pub Op1);

/// cvtsd2ss xmm xmm: Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsd2ss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsd2ss xmm m64: Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsd2ss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtsi2sdl<Op0, Op1>(pub Op0, pub Op1);

/// cvtsi2sdl xmm r32: Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2sdl<Xmm, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsi2sdl xmm m32: Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2sdl<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtsi2sdq<Op0, Op1>(pub Op0, pub Op1);

/// cvtsi2sdq xmm r64: Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2sdq<Xmm, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsi2sdq xmm m64: Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2sdq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtsi2ssl<Op0, Op1>(pub Op0, pub Op1);

/// cvtsi2ssl xmm r32: Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2ssl<Xmm, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsi2ssl xmm m32: Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2ssl<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtsi2ssq<Op0, Op1>(pub Op0, pub Op1);

/// cvtsi2ssq xmm r64: Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2ssq<Xmm, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtsi2ssq xmm m64: Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtsi2ssq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtss2sd<Op0, Op1>(pub Op0, pub Op1);

/// cvtss2sd xmm xmm: Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtss2sd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtss2sd xmm m32: Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtss2sd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvtss2si<Op0, Op1>(pub Op0, pub Op1);

/// cvtss2si r32 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtss2si<Gpr32, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtss2si r32 m32: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtss2si<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtss2si r64 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtss2si<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvtss2si r64 m32: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvtss2si<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F 2D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvttpd2dq<Op0, Op1>(pub Op0, pub Op1);

/// cvttpd2dq xmm xmm: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttpd2dq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttpd2dq xmm m128: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttpd2dq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvttps2dq<Op0, Op1>(pub Op0, pub Op1);

/// cvttps2dq xmm xmm: Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttps2dq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttps2dq xmm m128: Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttps2dq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvttsd2si<Op0, Op1>(pub Op0, pub Op1);

/// cvttsd2si r32 xmm: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttsd2si<Gpr32, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttsd2si r32 m64: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttsd2si<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttsd2si r64 xmm: Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttsd2si<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttsd2si r64 m64: Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttsd2si<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 REX.W+ 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cvttss2si<Op0, Op1>(pub Op0, pub Op1);

/// cvttss2si r32 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttss2si<Gpr32, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttss2si r32 m32: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttss2si<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttss2si r64 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttss2si<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// cvttss2si r64 m32: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
impl<W: io::Write + ?Sized> WriteInst<W> for Cvttss2si<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F 2C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x2C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Cwtd();

/// cwtd: DX:AX = sign-extend of AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cwtd {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 99
        put(w, 0x66)?;
        put(w, 0x99)?;
        Ok(())
    }
}

pub struct Cwtl();

/// cwtl: EAX = sign-extend of AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Cwtl {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 98
        put(w, 0x98)?;
        Ok(())
    }
}

pub struct Decb<Op0>(pub Op0);

/// decb r8: Decrement r/m8 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FE /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// decb m8: Decrement r/m8 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FE /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Decl<Op0>(pub Op0);

/// decl r32: Decrement r/m32 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decl<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// decl m32: Decrement r/m32 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Decq<Op0>(pub Op0);

/// decq r64: Decrement r/m64 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ FF /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// decq m64: Decrement r/m64 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ FF /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Decw<Op0>(pub Op0);

/// decw r16: Decrement r/m16 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 FF /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// decw m16: Decrement r/m16 by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Decw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 FF /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divb<Op0>(pub Op0);

/// divb r8: Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divb m8: Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divl<Op0>(pub Op0);

/// divl r32: Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divl<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divl m32: Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divpd<Op0, Op1>(pub Op0, pub Op1);

/// divpd xmm xmm: Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Divpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divpd xmm m128: Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Divpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divps<Op0, Op1>(pub Op0, pub Op1);

/// divps xmm xmm: Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Divps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divps xmm m128: Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Divps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divq<Op0>(pub Op0);

/// divq r64: Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divq m64: Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divsd<Op0, Op1>(pub Op0, pub Op1);

/// divsd xmm xmm: Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
impl<W: io::Write + ?Sized> WriteInst<W> for Divsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divsd xmm m64: Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
impl<W: io::Write + ?Sized> WriteInst<W> for Divsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divss<Op0, Op1>(pub Op0, pub Op1);

/// divss xmm xmm: Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Divss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divss xmm m32: Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Divss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Divw<Op0>(pub Op0);

/// divw r16: Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// divw m16: Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Divw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Dppd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// dppd xmm xmm imm8: Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Dppd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 41 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x41)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// dppd xmm m128 imm8: Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Dppd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 41 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x41)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Dpps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// dpps xmm xmm imm8: Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Dpps<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 40 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x40)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// dpps xmm m128 imm8: Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Dpps<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 40 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x40)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Emms();

/// emms: Set the x87 FPU tag word to empty.
impl<W: io::Write + ?Sized> WriteInst<W> for Emms {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 77
        put(w, 0x0F)?;
        put(w, 0x77)?;
        Ok(())
    }
}

pub struct Extractps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// extractps reg xmm imm8: Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Extractps<Gpr64, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 17 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x17)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// extractps m32 xmm imm8: Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Extractps<Memory, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 17 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x17)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Hlt();

/// hlt: Halt
impl<W: io::Write + ?Sized> WriteInst<W> for Hlt {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F4
        put(w, 0xF4)?;
        Ok(())
    }
}

pub struct Idivb<Op0>(pub Op0);

/// idivb r8: Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// idivb m8: Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Idivl<Op0>(pub Op0);

/// idivl r32: Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivl<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// idivl m32: Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Idivq<Op0>(pub Op0);

/// idivq r64: Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// idivq m64: Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Idivw<Op0>(pub Op0);

/// idivw r16: Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// idivw m16: Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
impl<W: io::Write + ?Sized> WriteInst<W> for Idivw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imulb<Op0>(pub Op0);

/// imulb r8: AX= AL * r/m byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imulb m8: AX= AL * r/m byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imull<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// imull r32 r32 imm8: doubleword register = r/m32 * sign- extended immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull<Gpr32, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 6B /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imull r32 m32 imm8: doubleword register = r/m32 * sign- extended immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull<Gpr32, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 6B /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imull r32 r32 imm32: doubleword register = r/m32 * immediate doubleword.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull<Gpr32, Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 69 /r id
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imull r32 m32 imm32: doubleword register = r/m32 * immediate doubleword.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull<Gpr32, Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 69 /r id
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Imull1<Op0>(pub Op0);

/// imull r32: EDX:EAX = EAX * r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull1<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imull m32: EDX:EAX = EAX * r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull1<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imull2<Op0, Op1>(pub Op0, pub Op1);

/// imull r32 r32: doubleword register = doubleword register *  r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull2<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imull r32 m32: doubleword register = doubleword register *  r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Imull2<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imulq<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// imulq r64 r64 imm8: Quadword register = r/m64 * sign-extended  immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq<Gpr64, Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 6B /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imulq r64 m64 imm8: Quadword register = r/m64 * sign-extended  immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq<Gpr64, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 6B /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imulq r64 r64 imm32: Quadword register = r/m64 * immediate doubleword.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq<Gpr64, Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 69 /r id
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imulq r64 m64 imm32: Quadword register = r/m64 * immediate doubleword.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq<Gpr64, Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 69 /r id
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Imulq1<Op0>(pub Op0);

/// imulq r64: RDX:RAX = RAX * r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq1<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imulq m64: RDX:RAX = RAX * r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq1<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imulq2<Op0, Op1>(pub Op0, pub Op1);

/// imulq r64 r64: Quadword register = Quadword register *  r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq2<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imulq r64 m64: Quadword register = Quadword register *  r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulq2<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imulw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// imulw r16 r16 imm8: word register = r/m16 * sign-extended immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw<Gpr16, Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 6B /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imulw r16 m16 imm8: word register = r/m16 * sign-extended immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw<Gpr16, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 6B /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imulw r16 r16 imm16: word register = r/m16 * immediate word.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw<Gpr16, Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 69 /r iw
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// imulw r16 m16 imm16: word register = r/m16 * immediate word.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw<Gpr16, Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 69 /r iw
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Imulw1<Op0>(pub Op0);

/// imulw r16: DX:AX = AX * r/m word.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw1<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imulw m16: DX:AX = AX * r/m word.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw1<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Imulw2<Op0, Op1>(pub Op0, pub Op1);

/// imulw r16 r16: word register = word register * r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw2<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AF /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// imulw r16 m16: word register = word register * r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Imulw2<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AF /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Inb<Op0, Op1>(pub Op0, pub Op1);

/// inb _Al imm8: Input byte from imm8 I/O port address into AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Inb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E4 ib
        put(w, 0xE4)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// inb _Al _Dx: Input byte from I/O port in DX into AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Inb<_Al, _Dx> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // EC
        put(w, 0xEC)?;
        Ok(())
    }
}

pub struct Incb<Op0>(pub Op0);

/// incb r8: Increment r/m byte by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FE /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// incb m8: Increment r/m byte by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FE /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Incl<Op0>(pub Op0);

/// incl r32: Increment r/m doubleword by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incl<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// incl m32: Increment r/m doubleword by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Incq<Op0>(pub Op0);

/// incq r64: Increment r/m quadword by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ FF /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// incq m64: Increment r/m quadword by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ FF /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Incw<Op0>(pub Op0);

/// incw r16: Increment r/m word by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 FF /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// incw m16: Increment r/m word by 1.
impl<W: io::Write + ?Sized> WriteInst<W> for Incw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 FF /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Inl<Op0, Op1>(pub Op0, pub Op1);

/// inl _Eax imm8: Input dword from imm8 I/O port address into EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Inl<_Eax, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E5 ib
        put(w, 0xE5)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// inl _Eax _Dx: Input doubleword from I/O port in DX into EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Inl<_Eax, _Dx> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // ED
        put(w, 0xED)?;
        Ok(())
    }
}

pub struct Insertps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// insertps xmm xmm imm8: Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Insertps<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 21 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// insertps xmm m32 imm8: Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Insertps<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 21 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Int<Op0>(pub Op0);

/// int imm8: Interrupt vector number specified by immediate byte.
impl<W: io::Write + ?Sized> WriteInst<W> for Int<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // CD ib
        put(w, 0xCD)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// int _3: Interrupt 3-trap to debugger.
impl<W: io::Write + ?Sized> WriteInst<W> for Int<_3> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // CC
        put(w, 0xCC)?;
        Ok(())
    }
}

pub struct Invd();

/// invd: Flush internal caches; initiate flushing of external caches.
impl<W: io::Write + ?Sized> WriteInst<W> for Invd {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 08
        put(w, 0x0F)?;
        put(w, 0x08)?;
        Ok(())
    }
}

pub struct Invlpg<Op0>(pub Op0);

/// invlpg m: Invalidate TLB Entry for page that contains m.
impl<W: io::Write + ?Sized> WriteInst<W> for Invlpg<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Inw<Op0, Op1>(pub Op0, pub Op1);

/// inw _Ax imm8: Input word from imm8 I/O port address into AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Inw<_Ax, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 E5 ib
        put(w, 0x66)?;
        put(w, 0xE5)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// inw _Ax _Dx: Input word from I/O port in DX into AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Inw<_Ax, _Dx> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 ED
        put(w, 0x66)?;
        put(w, 0xED)?;
        Ok(())
    }
}

pub struct Iretl();

/// iretl: Interrupt return (32-bit operand size).
impl<W: io::Write + ?Sized> WriteInst<W> for Iretl {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // CF
        put(w, 0xCF)?;
        Ok(())
    }
}

pub struct Iretq();

/// iretq: Interrupt return (64-bit operand size).
impl<W: io::Write + ?Sized> WriteInst<W> for Iretq {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ CF
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0xCF)?;
        Ok(())
    }
}

pub struct Iretw();

/// iretw: Interrupt return (16-bit operand size).
impl<W: io::Write + ?Sized> WriteInst<W> for Iretw {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 CF
        put(w, 0x66)?;
        put(w, 0xCF)?;
        Ok(())
    }
}

pub struct Ja<Op0>(pub Op0);

/// ja rel8: Jump short if above (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Ja<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 77 cb
        put(w, 0x77)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// ja rel32: Jump near if above (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Ja<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 87 cd
        put(w, 0x0F)?;
        put(w, 0x87)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jae<Op0>(pub Op0);

/// jae rel8: Jump short if above or equal (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jae<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 73 cb
        put(w, 0x73)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jae rel32: Jump near if above or equal (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jae<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 83 cd
        put(w, 0x0F)?;
        put(w, 0x83)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jb<Op0>(pub Op0);

/// jb rel8: Jump short if below (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jb<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 72 cb
        put(w, 0x72)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jb rel32: Jump near if below (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jb<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 82 cd
        put(w, 0x0F)?;
        put(w, 0x82)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jbe<Op0>(pub Op0);

/// jbe rel8: Jump short if below or equal (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jbe<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 76 cb
        put(w, 0x76)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jbe rel32: Jump near if below or equal (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jbe<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 86 cd
        put(w, 0x0F)?;
        put(w, 0x86)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jc<Op0>(pub Op0);

/// jc rel8: Jump short if carry (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jc<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 72 cb
        put(w, 0x72)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jc rel32: Jump near if carry (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jc<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 82 cd
        put(w, 0x0F)?;
        put(w, 0x82)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Je<Op0>(pub Op0);

/// je rel8: Jump short if equal (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Je<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 74 cb
        put(w, 0x74)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// je rel32: Jump near if 0 (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Je<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 84 cd
        put(w, 0x0F)?;
        put(w, 0x84)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jecxz<Op0>(pub Op0);

/// jecxz rel8: Jump short if ECX register is 0.
impl<W: io::Write + ?Sized> WriteInst<W> for Jecxz<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E3 cb
        put(w, 0xE3)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jg<Op0>(pub Op0);

/// jg rel8: Jump short if greater (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jg<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7F cb
        put(w, 0x7F)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jg rel32: Jump near if greater (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jg<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8F cd
        put(w, 0x0F)?;
        put(w, 0x8F)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jge<Op0>(pub Op0);

/// jge rel8: Jump short if greater or equal (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jge<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7D cb
        put(w, 0x7D)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jge rel32: Jump near if greater or equal (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jge<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8D cd
        put(w, 0x0F)?;
        put(w, 0x8D)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jl<Op0>(pub Op0);

/// jl rel8: Jump short if less (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jl<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7C cb
        put(w, 0x7C)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jl rel32: Jump near if less (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jl<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8C cd
        put(w, 0x0F)?;
        put(w, 0x8C)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jle<Op0>(pub Op0);

/// jle rel8: Jump short if less or equal (ZF=1 or SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jle<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7E cb
        put(w, 0x7E)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jle rel32: Jump near if less or equal (ZF=1 or SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jle<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8E cd
        put(w, 0x0F)?;
        put(w, 0x8E)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jmpq<Op0>(pub Op0);

/// jmpq rel8: Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits
impl<W: io::Write + ?Sized> WriteInst<W> for Jmpq<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // EB cb
        put(w, 0xEB)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jmpq rel32: Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits
impl<W: io::Write + ?Sized> WriteInst<W> for Jmpq<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E9 cd
        put(w, 0xE9)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jmpq r64: Jump near, absolute indirect, RIP = 64-Bit offset from register or memory
impl<W: io::Write + ?Sized> WriteInst<W> for Jmpq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// jmpq m64: Jump near, absolute indirect, RIP = 64-Bit offset from register or memory
impl<W: io::Write + ?Sized> WriteInst<W> for Jmpq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Jna<Op0>(pub Op0);

/// jna rel8: Jump short if not above (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jna<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 76 cb
        put(w, 0x76)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jna rel32: Jump near if not above (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jna<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 86 cd
        put(w, 0x0F)?;
        put(w, 0x86)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnae<Op0>(pub Op0);

/// jnae rel8: Jump short if not above or equal (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnae<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 72 cb
        put(w, 0x72)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnae rel32: Jump near if not above or equal (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnae<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 82 cd
        put(w, 0x0F)?;
        put(w, 0x82)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnb<Op0>(pub Op0);

/// jnb rel8: Jump short if not below (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnb<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 73 cb
        put(w, 0x73)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnb rel32: Jump near if not below (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnb<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 83 cd
        put(w, 0x0F)?;
        put(w, 0x83)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnbe<Op0>(pub Op0);

/// jnbe rel8: Jump short if not below or equal (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnbe<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 77 cb
        put(w, 0x77)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnbe rel32: Jump near if not below or equal (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnbe<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 87 cd
        put(w, 0x0F)?;
        put(w, 0x87)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnc<Op0>(pub Op0);

/// jnc rel8: Jump short if not carry (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnc<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 73 cb
        put(w, 0x73)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnc rel32: Jump near if not carry (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnc<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 83 cd
        put(w, 0x0F)?;
        put(w, 0x83)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jne<Op0>(pub Op0);

/// jne rel8: Jump short if not equal (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jne<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 75 cb
        put(w, 0x75)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jne rel32: Jump near if not equal (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jne<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 85 cd
        put(w, 0x0F)?;
        put(w, 0x85)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jng<Op0>(pub Op0);

/// jng rel8: Jump short if not greater (ZF=1 or SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jng<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7E cb
        put(w, 0x7E)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jng rel32: Jump near if not greater (ZF=1 or SF != OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jng<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8E cd
        put(w, 0x0F)?;
        put(w, 0x8E)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnge<Op0>(pub Op0);

/// jnge rel8: Jump short if not greater or equal (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnge<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7C cb
        put(w, 0x7C)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnge rel32: Jump near if not greater or equal (SF != OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnge<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8C cd
        put(w, 0x0F)?;
        put(w, 0x8C)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnl<Op0>(pub Op0);

/// jnl rel8: Jump short if not less (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnl<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7D cb
        put(w, 0x7D)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnl rel32: Jump near if not less (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnl<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8D cd
        put(w, 0x0F)?;
        put(w, 0x8D)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnle<Op0>(pub Op0);

/// jnle rel8: Jump short if not less or equal (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnle<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7F cb
        put(w, 0x7F)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnle rel32: Jump near if not less or equal (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnle<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8F cd
        put(w, 0x0F)?;
        put(w, 0x8F)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jno<Op0>(pub Op0);

/// jno rel8: Jump short if not overflow (OF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jno<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 71 cb
        put(w, 0x71)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jno rel32: Jump near if not overflow (OF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jno<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 81 cd
        put(w, 0x0F)?;
        put(w, 0x81)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnp<Op0>(pub Op0);

/// jnp rel8: Jump short if not parity (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnp<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7B cb
        put(w, 0x7B)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnp rel32: Jump near if not parity (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnp<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8B cd
        put(w, 0x0F)?;
        put(w, 0x8B)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jns<Op0>(pub Op0);

/// jns rel8: Jump short if not sign (SF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jns<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 79 cb
        put(w, 0x79)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jns rel32: Jump near if not sign (SF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jns<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 89 cd
        put(w, 0x0F)?;
        put(w, 0x89)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jnz<Op0>(pub Op0);

/// jnz rel8: Jump short if not zero (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnz<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 75 cb
        put(w, 0x75)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jnz rel32: Jump near if not zero (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jnz<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 85 cd
        put(w, 0x0F)?;
        put(w, 0x85)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jo<Op0>(pub Op0);

/// jo rel8: Jump short if overflow (OF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jo<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 70 cb
        put(w, 0x70)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jo rel32: Jump near if overflow (OF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jo<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 80 cd
        put(w, 0x0F)?;
        put(w, 0x80)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jp<Op0>(pub Op0);

/// jp rel8: Jump short if parity (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jp<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7A cb
        put(w, 0x7A)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jp rel32: Jump near if parity (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jp<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8A cd
        put(w, 0x0F)?;
        put(w, 0x8A)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jpe<Op0>(pub Op0);

/// jpe rel8: Jump short if parity even (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jpe<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7A cb
        put(w, 0x7A)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jpe rel32: Jump near if parity even (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jpe<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8A cd
        put(w, 0x0F)?;
        put(w, 0x8A)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jpo<Op0>(pub Op0);

/// jpo rel8: Jump short if parity odd (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jpo<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 7B cb
        put(w, 0x7B)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jpo rel32: Jump near if parity odd (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Jpo<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 8B cd
        put(w, 0x0F)?;
        put(w, 0x8B)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jrcxz<Op0>(pub Op0);

/// jrcxz rel8: Jump short if RCX register is 0.
impl<W: io::Write + ?Sized> WriteInst<W> for Jrcxz<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E3 cb
        put(w, 0xE3)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Js<Op0>(pub Op0);

/// js rel8: Jump short if sign (SF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Js<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 78 cb
        put(w, 0x78)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// js rel32: Jump near if sign (SF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Js<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 88 cd
        put(w, 0x0F)?;
        put(w, 0x88)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Jz<Op0>(pub Op0);

/// jz rel8: Jump short if zero (ZF = 1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jz<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 74 cb
        put(w, 0x74)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// jz rel32: Jump near if 0 (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Jz<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 84 cd
        put(w, 0x0F)?;
        put(w, 0x84)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Ldmxcsr<Op0>(pub Op0);

/// ldmxcsr m32: Load MXCSR register from m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Ldmxcsr<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AE /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Leal<Op0, Op1>(pub Op0, pub Op1);

/// leal r32 m: Store effective address for m in register r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Leal<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 8D /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Leaq<Op0, Op1>(pub Op0, pub Op1);

/// leaq r64 m: Store effective address for m in register r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Leaq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 8D /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x8D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Leaveq();

/// leaveq: Set RSP to RBP, then pop RBP.
impl<W: io::Write + ?Sized> WriteInst<W> for Leaveq {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C9
        put(w, 0xC9)?;
        Ok(())
    }
}

pub struct Leavew();

/// leavew: Set SP to BP, then pop BP.
impl<W: io::Write + ?Sized> WriteInst<W> for Leavew {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C9
        put(w, 0x66)?;
        put(w, 0xC9)?;
        Ok(())
    }
}

pub struct Leaw<Op0, Op1>(pub Op0, pub Op1);

/// leaw r16 m: Store effective address for m in register r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Leaw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 8D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Lfence();

/// lfence: Serializes load operations.
impl<W: io::Write + ?Sized> WriteInst<W> for Lfence {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AE E8
        put(w, 0x0F)?;
        put(w, 0xAE)?;
        put(w, 0xE8)?;
        Ok(())
    }
}

pub struct Lmsw<Op0>(pub Op0);

/// lmsw r16: Loads r/m16 in machine status word of CR0.
impl<W: io::Write + ?Sized> WriteInst<W> for Lmsw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// lmsw m16: Loads r/m16 in machine status word of CR0.
impl<W: io::Write + ?Sized> WriteInst<W> for Lmsw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Lock();

/// lock: Asserts LOCK# signal for duration of the accompanying instruction.
impl<W: io::Write + ?Sized> WriteInst<W> for Lock {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F0
        put(w, 0xF0)?;
        Ok(())
    }
}

pub struct Maskmovdqu<Op0, Op1>(pub Op0, pub Op1);

/// maskmovdqu xmm xmm: Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.
impl<W: io::Write + ?Sized> WriteInst<W> for Maskmovdqu<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F7 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Maxpd<Op0, Op1>(pub Op0, pub Op1);

/// maxpd xmm xmm: Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// maxpd xmm m128: Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Maxps<Op0, Op1>(pub Op0, pub Op1);

/// maxps xmm xmm: Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// maxps xmm m128: Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Maxsd<Op0, Op1>(pub Op0, pub Op1);

/// maxsd xmm xmm: Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// maxsd xmm m64: Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Maxss<Op0, Op1>(pub Op0, pub Op1);

/// maxss xmm xmm: Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// maxss xmm m32: Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Maxss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mfence();

/// mfence: Serializes load and store operations.
impl<W: io::Write + ?Sized> WriteInst<W> for Mfence {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AE F0
        put(w, 0x0F)?;
        put(w, 0xAE)?;
        put(w, 0xF0)?;
        Ok(())
    }
}

pub struct Minpd<Op0, Op1>(pub Op0, pub Op1);

/// minpd xmm xmm: Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// minpd xmm m128: Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Minps<Op0, Op1>(pub Op0, pub Op1);

/// minps xmm xmm: Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// minps xmm m128: Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Minsd<Op0, Op1>(pub Op0, pub Op1);

/// minsd xmm xmm: Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// minsd xmm m64: Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Minss<Op0, Op1>(pub Op0, pub Op1);

/// minss xmm xmm: Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// minss xmm m32: Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Minss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movapd<Op0, Op1>(pub Op0, pub Op1);

/// movapd xmm xmm: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movapd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 28 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movapd xmm m128: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movapd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 28 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movapd m128 xmm: Move packed double-precision floating-point values from xmm1 to xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Movapd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 29 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movaps<Op0, Op1>(pub Op0, pub Op1);

/// movaps xmm xmm: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movaps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 28 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movaps xmm m128: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movaps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 28 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movaps m128 xmm: Move packed single-precision floating-point values from xmm1 to xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Movaps<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 29 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movb<Op0, Op1>(pub Op0, pub Op1);

/// movb r8 imm8: Move imm8 to r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Movb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // B0 +rb ib
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(false))?;
        put(w, 0xB0 + rio.byte_added_to_opcode)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// movb r8 r8: Move r/m8 to r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Movb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 8A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movb r8 m8: Move r/m8 to r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Movb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 8A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movb m8 r8: Move r8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Movb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 88 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x88)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movb m8 imm8: Move imm8 to r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Movb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C6 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Movd<Op0, Op1>(pub Op0, pub Op1);

/// movd r32 xmm: Move doubleword from xmm register to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movd<Gpr32, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 7E /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x7E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movd m32 xmm: Move doubleword from xmm register to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 7E /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x7E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movd xmm r32: Move doubleword from r/m32 to xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movd<Xmm, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movd xmm m32: Move doubleword from r/m32 to xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movdqa<Op0, Op1>(pub Op0, pub Op1);

/// movdqa xmm xmm: Move aligned double quadword from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movdqa<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movdqa xmm m128: Move aligned double quadword from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movdqa<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movdqa m128 xmm: Move aligned double quadword from xmm1 to xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Movdqa<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 7F /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x7F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movdqu<Op0, Op1>(pub Op0, pub Op1);

/// movdqu xmm xmm: Move unaligned double quadword from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movdqu<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 6F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movdqu xmm m128: Move unaligned double quadword from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movdqu<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 6F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movdqu m128 xmm: Move unaligned double quadword from xmm1 to xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Movdqu<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 7F /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x7F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movhlps<Op0, Op1>(pub Op0, pub Op1);

/// movhlps xmm xmm: Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movhlps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 12 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x12)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movhpd<Op0, Op1>(pub Op0, pub Op1);

/// movhpd m64 xmm: Move double-precision floating-point value from high quadword of xmm to m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movhpd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 17 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x17)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movhpd xmm m64: Move double-precision floating-point value from m64 to high quadword of xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movhpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 16 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movhps<Op0, Op1>(pub Op0, pub Op1);

/// movhps m64 xmm: Move two packed single-precision floating-point values from high quadword of xmm to m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movhps<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 17 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x17)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movhps xmm m64: Move two packed single-precision floating-point values from m64 to high quadword of xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movhps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 16 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movl<Op0, Op1>(pub Op0, pub Op1);

/// movl r32 imm32: Move imm32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // B8 +rd id
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(false))?;
        put(w, 0xB8 + rio.byte_added_to_opcode)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// movl r32 r32: Move r/m32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 8B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movl r32 m32: Move r/m32 to r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 8B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movl m32 r32: Move r32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 89 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x89)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movl m32 imm32: Move imm32 to r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Movlhps<Op0, Op1>(pub Op0, pub Op1);

/// movlhps xmm xmm: Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movlhps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 16 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movlpd<Op0, Op1>(pub Op0, pub Op1);

/// movlpd m64 xmm: Move double-precision floating-point nvalue from low quadword of xmm register to m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movlpd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 13 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movlpd xmm m64: Move double-precision floating-point value from m64 to low quadword of xmm register.
impl<W: io::Write + ?Sized> WriteInst<W> for Movlpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 12 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x12)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movlps<Op0, Op1>(pub Op0, pub Op1);

/// movlps m64 xmm: Move two packed single-precision floating-point values from low quadword of xmm to m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movlps<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 13 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x13)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movlps xmm m64: Move two packed single-precision floating-point values from m64 to low quadword of xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movlps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 12 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x12)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movmskpd<Op0, Op1>(pub Op0, pub Op1);

/// movmskpd reg xmm: Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.
impl<W: io::Write + ?Sized> WriteInst<W> for Movmskpd<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 50 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x50)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movmskps<Op0, Op1>(pub Op0, pub Op1);

/// movmskps reg xmm: Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.
impl<W: io::Write + ?Sized> WriteInst<W> for Movmskps<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 50 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x50)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movntdq<Op0, Op1>(pub Op0, pub Op1);

/// movntdq m128 xmm: Move double quadword from xmm to m128 using non-temporal hint.
impl<W: io::Write + ?Sized> WriteInst<W> for Movntdq<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E7 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movntdqa<Op0, Op1>(pub Op0, pub Op1);

/// movntdqa xmm m128: Move double quadword from m128 to xmm using non-temporal hint if WC memory type.
impl<W: io::Write + ?Sized> WriteInst<W> for Movntdqa<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 2A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movnti<Op0, Op1>(pub Op0, pub Op1);

/// movnti m32 r32: Move doubleword from r32 to m32 using non-temporal hint.
impl<W: io::Write + ?Sized> WriteInst<W> for Movnti<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movnti m64 r64: Move quadword from r64 to m64 using non-temporal hint.
impl<W: io::Write + ?Sized> WriteInst<W> for Movnti<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F C3 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xC3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movntpd<Op0, Op1>(pub Op0, pub Op1);

/// movntpd m128 xmm: Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.
impl<W: io::Write + ?Sized> WriteInst<W> for Movntpd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 2B /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movntps<Op0, Op1>(pub Op0, pub Op1);

/// movntps m128 xmm: Move packed single-precision floating-point values from xmm to m128 using non-temporal hint.
impl<W: io::Write + ?Sized> WriteInst<W> for Movntps<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 2B /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movq<Op0, Op1>(pub Op0, pub Op1);

/// movq r64 imm64: Move imm64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Gpr64, i64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ B8 +ro io
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(true))?;
        put(w, 0xB8 + rio.byte_added_to_opcode)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// movq r64 r64: Move r/m64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 8B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x8B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq r64 m64: Move r/m64 to r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 8B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x8B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq m64 r64: Move r64 to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 89 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x89)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq r64 imm32: Move imm32 sign extended to 64-bits to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// movq m64 imm32: Move imm32 sign extended to 64-bits to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// movq r64 xmm: Move quadword from xmm register to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 REX.W+ 0F 7E /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x7E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq m64 xmm: Move quadword from xmm register to r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 REX.W+ 0F 7E /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x7E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq xmm r64: Move quadword from r/m64 to xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Xmm, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 REX.W+ 0F 6E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x6E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq xmm m64: Move quadword from r/m64 to xmm.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 REX.W+ 0F 6E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x6E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movq xmm xmm: Move quadword from xmm2/mem64 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 7E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x7E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movsbl<Op0, Op1>(pub Op0, pub Op1);

/// movsbl r32 r8: Move byte to doubleword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsbl<Gpr32, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BE /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movsbl r32 m8: Move byte to doubleword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsbl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BE /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movsbq<Op0, Op1>(pub Op0, pub Op1);

/// movsbq r64 r8: Move byte to quadword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsbq<Gpr64, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BE /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movsbq r64 m8: Move byte to quadword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsbq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BE /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movsbw<Op0, Op1>(pub Op0, pub Op1);

/// movsbw r16 r8: Move byte to word with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsbw<Gpr16, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movsbw r16 m8: Move byte to word with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsbw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F BE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movsd<Op0, Op1>(pub Op0, pub Op1);

/// movsd xmm xmm: Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movsd xmm m64: Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movsd m64 xmm: Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 11 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movsl();

/// movsl: For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
impl<W: io::Write + ?Sized> WriteInst<W> for Movsl {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // A5
        put(w, 0xA5)?;
        Ok(())
    }
}

pub struct Movslq<Op0, Op1>(pub Op0, pub Op1);

/// movslq r64 r32: Move doubleword to quadword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movslq<Gpr64, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 63 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x63)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movslq r64 m32: Move doubleword to quadword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movslq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 63 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x63)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movss<Op0, Op1>(pub Op0, pub Op1);

/// movss xmm xmm: Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
impl<W: io::Write + ?Sized> WriteInst<W> for Movss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movss xmm m32: Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
impl<W: io::Write + ?Sized> WriteInst<W> for Movss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movss m32 xmm: Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Movss<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 11 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movswl<Op0, Op1>(pub Op0, pub Op1);

/// movswl r32 r16: Move word to doubleword, with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movswl<Gpr32, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movswl r32 m16: Move word to doubleword, with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movswl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F BF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xBF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movswq<Op0, Op1>(pub Op0, pub Op1);

/// movswq r64 r16: Move word to quadword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movswq<Gpr64, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movswq r64 m16: Move word to quadword with sign-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movswq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F BF /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xBF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movupd<Op0, Op1>(pub Op0, pub Op1);

/// movupd xmm xmm: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movupd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movupd xmm m128: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movupd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movupd m128 xmm: Move packed double-precision floating-point values from xmm1 to xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Movupd<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 11 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movups<Op0, Op1>(pub Op0, pub Op1);

/// movups xmm xmm: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movups<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movups xmm m128: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Movups<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 10 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movups m128 xmm: Move packed single-precision floating-point values from xmm1 to xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Movups<Memory, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 11 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x11)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movw<Op0, Op1>(pub Op0, pub Op1);

/// movw r16 imm16: Move imm16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Movw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 B8 +rw iw
        let rio = RegInOpcode::from(self.0);
        put(w, 0x66)?;
        puts(w, rio.rex_byte(false))?;
        put(w, 0xB8 + rio.byte_added_to_opcode)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// movw r16 r16: Move r/m16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Movw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 8B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movw r16 m16: Move r/m16 to r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Movw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 8B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movw m16 r16: Move r16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Movw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 89 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x89)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movw m16 imm16: Move imm16 to r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Movw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C7 /0 iw
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Movzbl<Op0, Op1>(pub Op0, pub Op1);

/// movzbl r32 r8: Move byte to doubleword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzbl<Gpr32, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B6 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movzbl r32 m8: Move byte to doubleword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzbl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B6 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movzbq<Op0, Op1>(pub Op0, pub Op1);

/// movzbq r64 r8: Move byte to quadword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzbq<Gpr64, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B6 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movzbq r64 m8: Move byte to quadword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzbq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B6 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movzbw<Op0, Op1>(pub Op0, pub Op1);

/// movzbw r16 r8: Move byte to word with zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzbw<Gpr16, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F B6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movzbw r16 m8: Move byte to word with zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzbw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F B6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movzwl<Op0, Op1>(pub Op0, pub Op1);

/// movzwl r32 r16: Move word to doubleword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzwl<Gpr32, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B7 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movzwl r32 m16: Move word to doubleword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzwl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F B7 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Movzwq<Op0, Op1>(pub Op0, pub Op1);

/// movzwq r64 r16: Move word to quadword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzwq<Gpr64, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B7 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// movzwq r64 m16: Move word to quadword, zero-extension.
impl<W: io::Write + ?Sized> WriteInst<W> for Movzwq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F B7 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mpsadbw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// mpsadbw xmm xmm imm8: Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Mpsadbw<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 42 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x42)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// mpsadbw xmm m128 imm8: Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Mpsadbw<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 42 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x42)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Mulb<Op0>(pub Op0);

/// mulb r8: Unsigned multiply (AX = AL * r/m8).
impl<W: io::Write + ?Sized> WriteInst<W> for Mulb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulb m8: Unsigned multiply (AX = AL * r/m8).
impl<W: io::Write + ?Sized> WriteInst<W> for Mulb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mull<Op0>(pub Op0);

/// mull r32: Unsigned multiply (EDX:EAX = EAX * r/m32).
impl<W: io::Write + ?Sized> WriteInst<W> for Mull<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mull m32: Unsigned multiply (EDX:EAX = EAX * r/m32).
impl<W: io::Write + ?Sized> WriteInst<W> for Mull<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mulpd<Op0, Op1>(pub Op0, pub Op1);

/// mulpd xmm xmm: Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulpd xmm m128: Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mulps<Op0, Op1>(pub Op0, pub Op1);

/// mulps xmm xmm: Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulps xmm m128: Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mulq<Op0>(pub Op0);

/// mulq r64: Unsigned multiply (RDX:RAX = RAX * r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulq m64: Unsigned multiply (RDX:RAX = RAX * r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mulsd<Op0, Op1>(pub Op0, pub Op1);

/// mulsd xmm xmm: Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulsd xmm m64: Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mulss<Op0, Op1>(pub Op0, pub Op1);

/// mulss xmm xmm: Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulss xmm m32: Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Mulss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 59 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x59)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Mulw<Op0>(pub Op0);

/// mulw r16: Unsigned multiply (DX:AX = AX * r/m16).
impl<W: io::Write + ?Sized> WriteInst<W> for Mulw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// mulw m16: Unsigned multiply (DX:AX = AX * r/m16).
impl<W: io::Write + ?Sized> WriteInst<W> for Mulw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Negb<Op0>(pub Op0);

/// negb r8: Two's complement negate r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Negb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// negb m8: Two's complement negate r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Negb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Negl<Op0>(pub Op0);

/// negl r32: Two's complement negate r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Negl<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// negl m32: Two's complement negate r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Negl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Negq<Op0>(pub Op0);

/// negq r64: Two's complement negate r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Negq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// negq m64: Two's complement negate r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Negq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Negw<Op0>(pub Op0);

/// negw r16: Two's complement negate r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Negw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// negw m16: Two's complement negate r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Negw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Nop();

/// nop: One byte no-operation instruction.
impl<W: io::Write + ?Sized> WriteInst<W> for Nop {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 90
        put(w, 0x90)?;
        Ok(())
    }
}

pub struct Notb<Op0>(pub Op0);

/// notb r8: Reverse each bit of r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Notb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// notb m8: Reverse each bit of r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Notb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Notl<Op0>(pub Op0);

/// notl r32: Reverse each bit of r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Notl<Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// notl m32: Reverse each bit of r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Notl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Notq<Op0>(pub Op0);

/// notq r64: Reverse each bit of r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Notq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// notq m64: Reverse each bit of r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Notq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Notw<Op0>(pub Op0);

/// notw r16: Reverse each bit of r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Notw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// notw m16: Reverse each bit of r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Notw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Orb<Op0, Op1>(pub Op0, pub Op1);

/// orb r8 r8: r8 OR r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Orb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orb r8 m8: r8 OR r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Orb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orb m8 r8: r/m8 OR r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Orb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 08 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x08)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orb r8 imm8: r/m8 OR imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Orb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orb m8 imm8: r/m8 OR imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Orb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orb _Al imm8: AL OR imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Orb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0C ib
        put(w, 0x0C)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Orl<Op0, Op1>(pub Op0, pub Op1);

/// orl r32 r32: r32 OR r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orl r32 m32: r32 OR r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orl m32 r32: r/m32 OR r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 09 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x09)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orl r32 imm8: r/m32 OR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orl m32 imm8: r/m32 OR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orl r32 imm32: r/m32 OR imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /1 id
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orl m32 imm32: r/m32 OR imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /1 id
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orl _Eax imm32: EAX OR imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Orl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0D id
        put(w, 0x0D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Orpd<Op0, Op1>(pub Op0, pub Op1);

/// orpd xmm xmm: Bitwise OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Orpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 56 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x56)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orpd xmm m128: Bitwise OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Orpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 56 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x56)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Orps<Op0, Op1>(pub Op0, pub Op1);

/// orps xmm xmm: Bitwise OR of xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Orps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 56 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x56)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orps xmm m128: Bitwise OR of xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Orps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 56 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x56)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Orq<Op0, Op1>(pub Op0, pub Op1);

/// orq r64 r64: r64 OR r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orq r64 m64: r64 OR r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orq m64 r64: r/m64 OR r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 09 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x09)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orq r64 imm8: r/m64 OR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orq m64 imm8: r/m64 OR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orq r64 imm32: r/m64 OR imm32 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /1 id
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orq m64 imm32: r/m64 OR imm32 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /1 id
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orq _Rax imm32: RAX OR imm32 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0D id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x0D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Orw<Op0, Op1>(pub Op0, pub Op1);

/// orw r16 r16: r16 OR r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orw r16 m16: r16 OR r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orw m16 r16: r/m16 OR r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 09 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x09)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// orw r16 imm8: r/m16 OR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orw m16 imm8: r/m16 OR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orw r16 imm16: r/m16 OR imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /1 iw
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orw m16 imm16: r/m16 OR imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /1 iw
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// orw _Ax imm16: AX OR imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Orw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0D iw
        put(w, 0x66)?;
        put(w, 0x0D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Outb<Op0, Op1>(pub Op0, pub Op1);

/// outb imm8 _Al: Output byte in AL to I/O port address imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Outb<i8, _Al> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E6 ib
        put(w, 0xE6)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// outb _Dx _Al: Output byte in AL to I/O port address in DX.
impl<W: io::Write + ?Sized> WriteInst<W> for Outb<_Dx, _Al> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // EE
        put(w, 0xEE)?;
        Ok(())
    }
}

pub struct Outl<Op0, Op1>(pub Op0, pub Op1);

/// outl imm8 _Eax: Output doubleword in EAX to I/O port address imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Outl<i8, _Eax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // E7 ib
        put(w, 0xE7)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// outl _Dx _Eax: Output doubleword in EAX to I/O port address in DX.
impl<W: io::Write + ?Sized> WriteInst<W> for Outl<_Dx, _Eax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // EF
        put(w, 0xEF)?;
        Ok(())
    }
}

pub struct Outw<Op0, Op1>(pub Op0, pub Op1);

/// outw imm8 _Ax: Output word in AX to I/O port address imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Outw<i8, _Ax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 E7 ib
        put(w, 0x66)?;
        put(w, 0xE7)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// outw _Dx _Ax: Output word in AX to I/O port address in DX.
impl<W: io::Write + ?Sized> WriteInst<W> for Outw<_Dx, _Ax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 EF
        put(w, 0x66)?;
        put(w, 0xEF)?;
        Ok(())
    }
}

pub struct Packssdw<Op0, Op1>(pub Op0, pub Op1);

/// packssdw xmm xmm: Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packssdw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// packssdw xmm m128: Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packssdw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Packsswb<Op0, Op1>(pub Op0, pub Op1);

/// packsswb xmm xmm: Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packsswb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 63 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x63)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// packsswb xmm m128: Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packsswb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 63 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x63)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Packusdw<Op0, Op1>(pub Op0, pub Op1);

/// packusdw xmm xmm: Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packusdw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 2B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// packusdw xmm m128: Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packusdw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 2B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Packuswb<Op0, Op1>(pub Op0, pub Op1);

/// packuswb xmm xmm: Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packuswb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 67 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x67)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// packuswb xmm m128: Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
impl<W: io::Write + ?Sized> WriteInst<W> for Packuswb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 67 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x67)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddb<Op0, Op1>(pub Op0, pub Op1);

/// paddb xmm xmm: Add packed byte integers from xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddb xmm m128: Add packed byte integers from xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddd<Op0, Op1>(pub Op0, pub Op1);

/// paddd xmm xmm: Add packed doubleword integers from xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddd xmm m128: Add packed doubleword integers from xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddq<Op0, Op1>(pub Op0, pub Op1);

/// paddq xmm xmm: Add packed quadword integers xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D4 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddq xmm m128: Add packed quadword integers xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D4 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddsb<Op0, Op1>(pub Op0, pub Op1);

/// paddsb xmm xmm: Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddsb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddsb xmm m128: Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddsb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddsw<Op0, Op1>(pub Op0, pub Op1);

/// paddsw xmm xmm: Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddsw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F ED /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xED)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddsw xmm m128: Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddsw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F ED /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xED)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddusb<Op0, Op1>(pub Op0, pub Op1);

/// paddusb xmm xmm: Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddusb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddusb xmm m128: Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddusb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DC /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddusw<Op0, Op1>(pub Op0, pub Op1);

/// paddusw xmm xmm: Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddusw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DD /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddusw xmm m128: Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddusw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DD /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Paddw<Op0, Op1>(pub Op0, pub Op1);

/// paddw xmm xmm: Add packed word integers from xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FD /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// paddw xmm m128: Add packed word integers from xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Paddw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FD /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pand<Op0, Op1>(pub Op0, pub Op1);

/// pand xmm xmm: Bitwise AND of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pand<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DB /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pand xmm m128: Bitwise AND of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pand<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DB /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pandn<Op0, Op1>(pub Op0, pub Op1);

/// pandn xmm xmm: Bitwise AND NOT of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pandn<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DF /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pandn xmm m128: Bitwise AND NOT of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pandn<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DF /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pause();

/// pause: Gives hint to processor that improves performance of spin-wait loops.
impl<W: io::Write + ?Sized> WriteInst<W> for Pause {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 90
        put(w, 0xF3)?;
        put(w, 0x90)?;
        Ok(())
    }
}

pub struct Pavgb<Op0, Op1>(pub Op0, pub Op1);

/// pavgb xmm xmm: Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
impl<W: io::Write + ?Sized> WriteInst<W> for Pavgb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E0 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pavgb xmm m128: Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
impl<W: io::Write + ?Sized> WriteInst<W> for Pavgb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E0 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pavgw<Op0, Op1>(pub Op0, pub Op1);

/// pavgw xmm xmm: Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
impl<W: io::Write + ?Sized> WriteInst<W> for Pavgw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E3 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pavgw xmm m128: Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
impl<W: io::Write + ?Sized> WriteInst<W> for Pavgw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E3 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pblendvb<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pblendvb xmm xmm _Xmm0: Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pblendvb<Xmm, Xmm, _Xmm0> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pblendvb xmm m128 _Xmm0: Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pblendvb<Xmm, Memory, _Xmm0> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 10 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x10)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pblendw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pblendw xmm xmm imm8: Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pblendw<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0E /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pblendw xmm m128 imm8: Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pblendw<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0E /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pcmpeqb<Op0, Op1>(pub Op0, pub Op1);

/// pcmpeqb xmm xmm: Compare packed bytes in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 74 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x74)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpeqb xmm m128: Compare packed bytes in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 74 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x74)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpeqd<Op0, Op1>(pub Op0, pub Op1);

/// pcmpeqd xmm xmm: Compare packed doublewords in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 76 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x76)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpeqd xmm m128: Compare packed doublewords in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 76 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x76)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpeqq<Op0, Op1>(pub Op0, pub Op1);

/// pcmpeqq xmm xmm: Compare packed qwords in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 29 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpeqq xmm m128: Compare packed qwords in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 29 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpeqw<Op0, Op1>(pub Op0, pub Op1);

/// pcmpeqw xmm xmm: Compare packed words in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 75 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x75)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpeqw xmm m128: Compare packed words in xmm2/m128 and xmm1 for equality.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpeqw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 75 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x75)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpestri<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pcmpestri xmm xmm imm8: Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpestri<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 61 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x61)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pcmpestri xmm m128 imm8: Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpestri<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 61 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x61)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pcmpestrm<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pcmpestrm xmm xmm imm8: Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpestrm<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 60 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x60)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pcmpestrm xmm m128 imm8: Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpestrm<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 60 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x60)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pcmpgtb<Op0, Op1>(pub Op0, pub Op1);

/// pcmpgtb xmm xmm: Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 64 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x64)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpgtb xmm m128: Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 64 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x64)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpgtd<Op0, Op1>(pub Op0, pub Op1);

/// pcmpgtd xmm xmm: Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 66 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x66)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpgtd xmm m128: Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 66 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x66)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpgtq<Op0, Op1>(pub Op0, pub Op1);

/// pcmpgtq xmm xmm: Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 37 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x37)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpgtq xmm m128: Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 37 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x37)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpgtw<Op0, Op1>(pub Op0, pub Op1);

/// pcmpgtw xmm xmm: Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 65 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x65)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pcmpgtw xmm m128: Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpgtw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 65 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x65)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pcmpistri<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pcmpistri xmm xmm imm8: Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpistri<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 63 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x63)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pcmpistri xmm m128 imm8: Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpistri<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 63 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x63)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pcmpistrm<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pcmpistrm xmm xmm imm8: Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpistrm<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 62 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x62)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pcmpistrm xmm m128 imm8: Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
impl<W: io::Write + ?Sized> WriteInst<W> for Pcmpistrm<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 62 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x62)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pextrb<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pextrb reg xmm imm8: Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrb<Gpr64, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 14 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pextrb m8 xmm imm8: Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrb<Memory, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 14 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pextrd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pextrd r32 xmm imm8: Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrd<Gpr32, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 16 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pextrd m32 xmm imm8: Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrd<Memory, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 16 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pextrq<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pextrq r64 xmm imm8: Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrq<Gpr64, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 REX.W+ 0F 3A 16 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pextrq m64 xmm imm8: Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrq<Memory, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 REX.W+ 0F 3A 16 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x16)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pextrw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pextrw reg xmm imm8: Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrw<Gpr64, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C5 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pextrw m16 xmm imm8: Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Pextrw<Memory, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 15 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Phminposuw<Op0, Op1>(pub Op0, pub Op1);

/// phminposuw xmm xmm: Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Phminposuw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 41 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x41)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// phminposuw xmm m128: Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Phminposuw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 41 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x41)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pinsrb<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pinsrb xmm r32 imm8: Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Pinsrb<Xmm, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 20 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x20)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pinsrb xmm m8 imm8: Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Pinsrb<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 20 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x20)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pinsrd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pinsrd xmm r32 imm8: Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Pinsrd<Xmm, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 22 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x22)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pinsrd xmm m32 imm8: Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Pinsrd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 22 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x22)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pinsrw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pinsrw xmm r32 imm8: Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Pinsrw<Xmm, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C4 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pinsrw xmm m16 imm8: Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Pinsrw<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C4 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pmaddwd<Op0, Op1>(pub Op0, pub Op1);

/// pmaddwd xmm xmm: Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaddwd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F5 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaddwd xmm m128: Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaddwd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F5 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmaxsb<Op0, Op1>(pub Op0, pub Op1);

/// pmaxsb xmm xmm: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxsb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaxsb xmm m128: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxsb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmaxsd<Op0, Op1>(pub Op0, pub Op1);

/// pmaxsd xmm xmm: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaxsd xmm m128: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmaxsw<Op0, Op1>(pub Op0, pub Op1);

/// pmaxsw xmm xmm: Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxsw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaxsw xmm m128: Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxsw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmaxub<Op0, Op1>(pub Op0, pub Op1);

/// pmaxub xmm xmm: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxub<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaxub xmm m128: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxub<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DE /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmaxud<Op0, Op1>(pub Op0, pub Op1);

/// pmaxud xmm xmm: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxud<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaxud xmm m128: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxud<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3F /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmaxuw<Op0, Op1>(pub Op0, pub Op1);

/// pmaxuw xmm xmm: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxuw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmaxuw xmm m128: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmaxuw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pminsb<Op0, Op1>(pub Op0, pub Op1);

/// pminsb xmm xmm: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminsb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pminsb xmm m128: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminsb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pminsd<Op0, Op1>(pub Op0, pub Op1);

/// pminsd xmm xmm: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 39 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x39)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pminsd xmm m128: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 39 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x39)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pminsw<Op0, Op1>(pub Op0, pub Op1);

/// pminsw xmm xmm: Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminsw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EA /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pminsw xmm m128: Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminsw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EA /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pminub<Op0, Op1>(pub Op0, pub Op1);

/// pminub xmm xmm: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminub<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DA /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pminub xmm m128: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminub<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F DA /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xDA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pminud<Op0, Op1>(pub Op0, pub Op1);

/// pminud xmm xmm: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminud<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pminud xmm m128: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminud<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pminuw<Op0, Op1>(pub Op0, pub Op1);

/// pminuw xmm xmm: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminuw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pminuw xmm m128: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pminuw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 3A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x3A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovmskb<Op0, Op1>(pub Op0, pub Op1);

/// pmovmskb reg xmm: Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovmskb<Gpr64, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D7 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovsxbd<Op0, Op1>(pub Op0, pub Op1);

/// pmovsxbd xmm xmm: Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxbd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 21 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovsxbd xmm m32: Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxbd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 21 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x21)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovsxbq<Op0, Op1>(pub Op0, pub Op1);

/// pmovsxbq xmm xmm: Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxbq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 22 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x22)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovsxbq xmm m16: Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxbq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 22 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x22)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovsxbw<Op0, Op1>(pub Op0, pub Op1);

/// pmovsxbw xmm xmm: Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxbw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 20 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x20)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovsxbw xmm m64: Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxbw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 20 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x20)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovsxdq<Op0, Op1>(pub Op0, pub Op1);

/// pmovsxdq xmm xmm: Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxdq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 25 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x25)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovsxdq xmm m64: Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxdq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 25 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x25)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovsxwd<Op0, Op1>(pub Op0, pub Op1);

/// pmovsxwd xmm xmm: Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxwd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 23 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovsxwd xmm m64: Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxwd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 23 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x23)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovsxwq<Op0, Op1>(pub Op0, pub Op1);

/// pmovsxwq xmm xmm: Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxwq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 24 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x24)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovsxwq xmm m32: Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovsxwq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 24 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x24)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovzxbd<Op0, Op1>(pub Op0, pub Op1);

/// pmovzxbd xmm xmm: Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxbd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 31 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x31)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovzxbd xmm m32: Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxbd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 31 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x31)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovzxbq<Op0, Op1>(pub Op0, pub Op1);

/// pmovzxbq xmm xmm: Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxbq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 32 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x32)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovzxbq xmm m16: Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxbq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 32 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x32)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovzxbw<Op0, Op1>(pub Op0, pub Op1);

/// pmovzxbw xmm xmm: Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxbw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 30 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x30)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovzxbw xmm m64: Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxbw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 30 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x30)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovzxdq<Op0, Op1>(pub Op0, pub Op1);

/// pmovzxdq xmm xmm: Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxdq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 35 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x35)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovzxdq xmm m64: Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxdq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 35 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x35)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovzxwd<Op0, Op1>(pub Op0, pub Op1);

/// pmovzxwd xmm xmm: Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxwd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 33 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovzxwd xmm m64: Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxwd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 33 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmovzxwq<Op0, Op1>(pub Op0, pub Op1);

/// pmovzxwq xmm xmm: Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxwq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 34 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x34)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmovzxwq xmm m32: Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmovzxwq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 34 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x34)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmuldq<Op0, Op1>(pub Op0, pub Op1);

/// pmuldq xmm xmm: Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmuldq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 28 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmuldq xmm m128: Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmuldq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 28 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmulhuw<Op0, Op1>(pub Op0, pub Op1);

/// pmulhuw xmm xmm: Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmulhuw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E4 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmulhuw xmm m128: Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmulhuw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E4 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmulhw<Op0, Op1>(pub Op0, pub Op1);

/// pmulhw xmm xmm: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmulhw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E5 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmulhw xmm m128: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmulhw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E5 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmulld<Op0, Op1>(pub Op0, pub Op1);

/// pmulld xmm xmm: Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmulld<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 40 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x40)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmulld xmm m128: Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmulld<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 40 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x40)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmullw<Op0, Op1>(pub Op0, pub Op1);

/// pmullw xmm xmm: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmullw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D5 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmullw xmm m128: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmullw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D5 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pmuludq<Op0, Op1>(pub Op0, pub Op1);

/// pmuludq xmm xmm: Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmuludq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F4 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pmuludq xmm m128: Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pmuludq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F4 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Popcntl<Op0, Op1>(pub Op0, pub Op1);

/// popcntl r32 r32: POPCNT on r/m32
impl<W: io::Write + ?Sized> WriteInst<W> for Popcntl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F B8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// popcntl r32 m32: POPCNT on r/m32
impl<W: io::Write + ?Sized> WriteInst<W> for Popcntl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F B8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Popcntq<Op0, Op1>(pub Op0, pub Op1);

/// popcntq r64 r64: POPCNT on r/m64
impl<W: io::Write + ?Sized> WriteInst<W> for Popcntq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F B8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// popcntq r64 m64: POPCNT on r/m64
impl<W: io::Write + ?Sized> WriteInst<W> for Popcntq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 REX.W+ 0F B8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xB8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Popcntw<Op0, Op1>(pub Op0, pub Op1);

/// popcntw r16 r16: POPCNT on r/m16
impl<W: io::Write + ?Sized> WriteInst<W> for Popcntw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 66 0F B8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// popcntw r16 m16: POPCNT on r/m16
impl<W: io::Write + ?Sized> WriteInst<W> for Popcntw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 66 0F B8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xB8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Popfq();

/// popfq: Pop top of stack and zero-extend into RFLAGS.
impl<W: io::Write + ?Sized> WriteInst<W> for Popfq {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 9D
        put(w, 0x9D)?;
        Ok(())
    }
}

pub struct Popfw();

/// popfw: Pop top of stack into lower 16 bits of EFLAGS.
impl<W: io::Write + ?Sized> WriteInst<W> for Popfw {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 9D
        put(w, 0x66)?;
        put(w, 0x9D)?;
        Ok(())
    }
}

pub struct Popq<Op0>(pub Op0);

/// popq r64: Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.
impl<W: io::Write + ?Sized> WriteInst<W> for Popq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 58 +ro
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(false))?;
        put(w, 0x58 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// popq m64: Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.
impl<W: io::Write + ?Sized> WriteInst<W> for Popq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 8F /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Popw<Op0>(pub Op0);

/// popw r16: Pop top of stack into r16; increment stack pointer.
impl<W: io::Write + ?Sized> WriteInst<W> for Popw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 58 +rw
        let rio = RegInOpcode::from(self.0);
        put(w, 0x66)?;
        puts(w, rio.rex_byte(false))?;
        put(w, 0x58 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// popw m16: Pop top of stack into m16; increment stack pointer.
impl<W: io::Write + ?Sized> WriteInst<W> for Popw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 8F /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x8F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Por<Op0, Op1>(pub Op0, pub Op1);

/// por xmm xmm: Bitwise OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Por<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EB /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// por xmm m128: Bitwise OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Por<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EB /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psadbw<Op0, Op1>(pub Op0, pub Op1);

/// psadbw xmm xmm: Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
impl<W: io::Write + ?Sized> WriteInst<W> for Psadbw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psadbw xmm m128: Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
impl<W: io::Write + ?Sized> WriteInst<W> for Psadbw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F6 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pshufd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pshufd xmm xmm imm8: Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pshufd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 70 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x70)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pshufd xmm m128 imm8: Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pshufd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 70 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x70)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pshufhw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pshufhw xmm xmm imm8: Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pshufhw<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 70 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x70)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pshufhw xmm m128 imm8: Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pshufhw<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 70 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x70)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pshuflw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// pshuflw xmm xmm imm8: Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pshuflw<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 70 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x70)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// pshuflw xmm m128 imm8: Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pshuflw<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 70 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x70)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Pslld<Op0, Op1>(pub Op0, pub Op1);

/// pslld xmm imm8: Shift doublewords in xmm1 left by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Pslld<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 72 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x72)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// pslld xmm xmm: Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Pslld<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F2 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pslld xmm m128: Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Pslld<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F2 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pslldq<Op0, Op1>(pub Op0, pub Op1);

/// pslldq xmm imm8: Shift xmm1 left by imm8 bytes while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Pslldq<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 73 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x73)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Psllq<Op0, Op1>(pub Op0, pub Op1);

/// psllq xmm imm8: Shift quadwords in xmm1 left by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psllq<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 73 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x73)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psllq xmm xmm: Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psllq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F3 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psllq xmm m128: Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psllq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F3 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psllw<Op0, Op1>(pub Op0, pub Op1);

/// psllw xmm imm8: Shift words in xmm1 left by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psllw<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 71 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x71)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psllw xmm xmm: Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psllw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psllw xmm m128: Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psllw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psrad<Op0, Op1>(pub Op0, pub Op1);

/// psrad xmm imm8: Shift doublewords in xmm1 right by imm8 while shifting in sign bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrad<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 72 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x72)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psrad xmm xmm: Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrad<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E2 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psrad xmm m128: Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrad<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E2 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psraw<Op0, Op1>(pub Op0, pub Op1);

/// psraw xmm imm8: Shift words in xmm1 right by imm8 while shifting in sign bits
impl<W: io::Write + ?Sized> WriteInst<W> for Psraw<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 71 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x71)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psraw xmm xmm: Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Psraw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psraw xmm m128: Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
impl<W: io::Write + ?Sized> WriteInst<W> for Psraw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psrld<Op0, Op1>(pub Op0, pub Op1);

/// psrld xmm imm8: Shift doublewords in xmm1 right by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrld<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 72 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x72)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psrld xmm xmm: Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrld<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D2 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psrld xmm m128: Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrld<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D2 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psrldq<Op0, Op1>(pub Op0, pub Op1);

/// psrldq xmm imm8: Shift xmm1 right by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrldq<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 73 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x73)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Psrlq<Op0, Op1>(pub Op0, pub Op1);

/// psrlq xmm imm8: Shift quadwords in xmm1 right by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrlq<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 73 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x73)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psrlq xmm xmm: Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrlq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D3 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psrlq xmm m128: Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrlq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D3 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psrlw<Op0, Op1>(pub Op0, pub Op1);

/// psrlw xmm imm8: Shift words in xmm1 right by imm8 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrlw<Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 71 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x71)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// psrlw xmm xmm: Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrlw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psrlw xmm m128: Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Psrlw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D1 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubb<Op0, Op1>(pub Op0, pub Op1);

/// psubb xmm xmm: Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubb xmm m128: Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubd<Op0, Op1>(pub Op0, pub Op1);

/// psubd xmm xmm: Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FA /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubd xmm m128: Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FA /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFA)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubq<Op0, Op1>(pub Op0, pub Op1);

/// psubq xmm xmm: Subtract packed quadword integers in xmm1 from xmm2 /m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FB /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubq xmm m128: Subtract packed quadword integers in xmm1 from xmm2 /m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F FB /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xFB)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubsb<Op0, Op1>(pub Op0, pub Op1);

/// psubsb xmm xmm: Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubsb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubsb xmm m128: Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubsb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubsw<Op0, Op1>(pub Op0, pub Op1);

/// psubsw xmm xmm: Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubsw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E9 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE9)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubsw xmm m128: Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubsw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F E9 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xE9)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubusb<Op0, Op1>(pub Op0, pub Op1);

/// psubusb xmm xmm: Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubusb<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubusb xmm m128: Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubusb<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D8 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD8)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubusw<Op0, Op1>(pub Op0, pub Op1);

/// psubusw xmm xmm: Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubusw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D9 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD9)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubusw xmm m128: Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubusw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F D9 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xD9)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Psubw<Op0, Op1>(pub Op0, pub Op1);

/// psubw xmm xmm: Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F9 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF9)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// psubw xmm m128: Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Psubw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F F9 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xF9)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Ptest<Op0, Op1>(pub Op0, pub Op1);

/// ptest xmm xmm: Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Ptest<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 17 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x17)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// ptest xmm m128: Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
impl<W: io::Write + ?Sized> WriteInst<W> for Ptest<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 38 17 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x38)?;
        put(w, 0x17)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpckhbw<Op0, Op1>(pub Op0, pub Op1);

/// punpckhbw xmm xmm: Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhbw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 68 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x68)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpckhbw xmm m128: Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhbw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 68 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x68)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpckhdq<Op0, Op1>(pub Op0, pub Op1);

/// punpckhdq xmm xmm: Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhdq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpckhdq xmm m128: Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhdq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6A /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpckhqdq<Op0, Op1>(pub Op0, pub Op1);

/// punpckhqdq xmm xmm: Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhqdq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpckhqdq xmm m128: Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhqdq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6D /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpckhwd<Op0, Op1>(pub Op0, pub Op1);

/// punpckhwd xmm xmm: Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhwd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 69 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpckhwd xmm m128: Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckhwd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 69 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x69)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpcklbw<Op0, Op1>(pub Op0, pub Op1);

/// punpcklbw xmm xmm: Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpcklbw<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 60 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x60)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpcklbw xmm m128: Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpcklbw<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 60 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x60)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpckldq<Op0, Op1>(pub Op0, pub Op1);

/// punpckldq xmm xmm: Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckldq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 62 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x62)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpckldq xmm m128: Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpckldq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 62 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x62)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpcklqdq<Op0, Op1>(pub Op0, pub Op1);

/// punpcklqdq xmm xmm: Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpcklqdq<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpcklqdq xmm m128: Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpcklqdq<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 6C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x6C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Punpcklwd<Op0, Op1>(pub Op0, pub Op1);

/// punpcklwd xmm xmm: Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpcklwd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 61 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x61)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// punpcklwd xmm m128: Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Punpcklwd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 61 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x61)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pushfq();

/// pushfq: Push RFLAGS.
impl<W: io::Write + ?Sized> WriteInst<W> for Pushfq {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 9C
        put(w, 0x9C)?;
        Ok(())
    }
}

pub struct Pushfw();

/// pushfw: Push lower 16 bits of EFLAGS.
impl<W: io::Write + ?Sized> WriteInst<W> for Pushfw {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 9C
        put(w, 0x66)?;
        put(w, 0x9C)?;
        Ok(())
    }
}

pub struct Pushq<Op0>(pub Op0);

/// pushq r64: Push r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Pushq<Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 50 +ro
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(false))?;
        put(w, 0x50 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// pushq imm8: Push imm8 (sign-extended to 64-bits).
impl<W: io::Write + ?Sized> WriteInst<W> for Pushq<i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 6A ib
        put(w, 0x6A)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// pushq imm16: Push imm16 (sign-extended to 64-bits).
impl<W: io::Write + ?Sized> WriteInst<W> for Pushq<i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 68 iw
        put(w, 0x66)?;
        put(w, 0x68)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// pushq imm32: Push imm32 (sign-extended to 64-bits).
impl<W: io::Write + ?Sized> WriteInst<W> for Pushq<i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 68 id
        put(w, 0x68)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

/// pushq m64: Push r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Pushq<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FF /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pushw<Op0>(pub Op0);

/// pushw r16: Push r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Pushw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 50 +rw
        let rio = RegInOpcode::from(self.0);
        put(w, 0x66)?;
        puts(w, rio.rex_byte(false))?;
        put(w, 0x50 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// pushw m16: Push r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Pushw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 FF /6
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xFF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Pxor<Op0, Op1>(pub Op0, pub Op1);

/// pxor xmm xmm: Bitwise XOR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pxor<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EF /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// pxor xmm m128: Bitwise XOR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Pxor<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F EF /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xEF)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rclb<Op0, Op1>(pub Op0, pub Op1);

/// rclb r8 imm8: Rotate 9 bits (CF, r/m8) left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rclb m8 imm8: Rotate 9 bits (CF, r/m8) left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rclb r8 _1: Rotate 9 bits (CF, r/m8) left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclb m8 _1: Rotate 9 bits (CF, r/m8) left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclb r8 _Cl: Rotate 9 bits (CF, r/m8) left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclb m8 _Cl: Rotate 9 bits (CF, r/m8) left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcll<Op0, Op1>(pub Op0, pub Op1);

/// rcll r32 imm8: Rotate 33 bits (CF, r/m32) left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcll<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcll m32 imm8: Rotate 33 bits (CF, r/m32) left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcll<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcll r32 _1: Rotate 33 bits (CF, r/m32) left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcll<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcll m32 _1: Rotate 33 bits (CF, r/m32) left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcll<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcll r32 _Cl: Rotate 33 bits (CF, r/m32) left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcll<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcll m32 _Cl: Rotate 33 bits (CF, r/m32) left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcll<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rclq<Op0, Op1>(pub Op0, pub Op1);

/// rclq r64 imm8: Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rclq m64 imm8: Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rclq r64 _1: Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclq m64 _1: Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclq r64 _Cl: Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclq m64 _Cl: Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rclw<Op0, Op1>(pub Op0, pub Op1);

/// rclw r16 imm8: Rotate 17 bits (CF, r/m16) left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rclw m16 imm8: Rotate 17 bits (CF, r/m16) left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /2 ib
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rclw r16 _1: Rotate 17 bits (CF, r/m16) left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclw m16 _1: Rotate 17 bits (CF, r/m16) left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclw r16 _Cl: Rotate 17 bits (CF, r/m16) left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rclw m16 _Cl: Rotate 17 bits (CF, r/m16) left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rclw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /2
        let modrm = ModRM::new(PartOfOpcode(2), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcpps<Op0, Op1>(pub Op0, pub Op1);

/// rcpps xmm xmm: Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcpps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 53 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x53)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcpps xmm m128: Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcpps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 53 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x53)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcpss<Op0, Op1>(pub Op0, pub Op1);

/// rcpss xmm xmm: Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcpss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 53 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x53)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcpss xmm m32: Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcpss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 53 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x53)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcrb<Op0, Op1>(pub Op0, pub Op1);

/// rcrb r8 imm8: Rotate 9 bits (CF, r/m8) right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrb m8 imm8: Rotate 9 bits (CF, r/m8) right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrb r8 _1: Rotate 9 bits (CF, r/m8) right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrb m8 _1: Rotate 9 bits (CF, r/m8) right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrb r8 _Cl: Rotate 9 bits (CF, r/m8) right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrb m8 _Cl: Rotate 9 bits (CF, r/m8) right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcrl<Op0, Op1>(pub Op0, pub Op1);

/// rcrl r32 imm8: Rotate 33 bits (CF, r/m32) right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrl m32 imm8: Rotate 33 bits (CF, r/m32) right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrl r32 _1: Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrl<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrl m32 _1: Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrl<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrl r32 _Cl: Rotate 33 bits (CF, r/m32) right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrl<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrl m32 _Cl: Rotate 33 bits (CF, r/m32) right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrl<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcrq<Op0, Op1>(pub Op0, pub Op1);

/// rcrq r64 imm8: Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrq m64 imm8: Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrq r64 _1: Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrq m64 _1: Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrq r64 _Cl: Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrq m64 _Cl: Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rcrw<Op0, Op1>(pub Op0, pub Op1);

/// rcrw r16 imm8: Rotate 17 bits (CF, r/m16) right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrw m16 imm8: Rotate 17 bits (CF, r/m16) right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rcrw r16 _1: Rotate 17 bits (CF, r/m16) right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrw m16 _1: Rotate 17 bits (CF, r/m16) right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrw r16 _Cl: Rotate 17 bits (CF, r/m16) right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rcrw m16 _Cl: Rotate 17 bits (CF, r/m16) right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rcrw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Retq();

/// retq: Near return to calling procedure.
impl<W: io::Write + ?Sized> WriteInst<W> for Retq {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C3
        put(w, 0xC3)?;
        Ok(())
    }
}

pub struct Retq1<Op0>(pub Op0);

/// retq imm16: Near return to calling procedure and pop imm16 bytes from stack.
impl<W: io::Write + ?Sized> WriteInst<W> for Retq1<i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C2 iw
        put(w, 0xC2)?;
        puts(w, self.0.to_le_bytes())?;
        Ok(())
    }
}

pub struct Rolb<Op0, Op1>(pub Op0, pub Op1);

/// rolb r8 imm8: Rotate 8 bits r/m8 left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rolb m8 imm8: Rotate 8 bits r/m8 left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rolb r8 _1: Rotate 8 bits r/m8 left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolb m8 _1: Rotate 8 bits r/m8 left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolb r8 _Cl: Rotate 8 bits r/m8 left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolb m8 _Cl: Rotate 8 bits r/m8 left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Roll<Op0, Op1>(pub Op0, pub Op1);

/// roll r32 imm8: Rotate 32 bits r/m32 left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Roll<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// roll m32 imm8: Rotate 32 bits r/m32 left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Roll<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// roll r32 _1: Rotate 32 bits r/m32 left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Roll<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// roll m32 _1: Rotate 32 bits r/m32 left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Roll<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// roll r32 _Cl: Rotate 32 bits r/m32 left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Roll<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// roll m32 _Cl: Rotate 32 bits r/m32 left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Roll<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rolq<Op0, Op1>(pub Op0, pub Op1);

/// rolq r64 imm8: Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rolq m64 imm8: Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rolq r64 _1: Rotate 64 bits r/m64 left once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolq m64 _1: Rotate 64 bits r/m64 left once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolq r64 _Cl: Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolq m64 _Cl: Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rolw<Op0, Op1>(pub Op0, pub Op1);

/// rolw r16 imm8: Rotate 16 bits r/m16 left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rolw m16 imm8: Rotate 16 bits r/m16 left imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rolw r16 _1: Rotate 16 bits r/m16 left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolw m16 _1: Rotate 16 bits r/m16 left once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolw r16 _Cl: Rotate 16 bits r/m16 left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rolw m16 _Cl: Rotate 16 bits r/m16 left CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rolw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rorb<Op0, Op1>(pub Op0, pub Op1);

/// rorb r8 imm8: Rotate 8 bits r/m16 right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorb m8 imm8: Rotate 8 bits r/m16 right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorb r8 _1: Rotate 8 bits r/m8 right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorb m8 _1: Rotate 8 bits r/m8 right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorb r8 _Cl: Rotate 8 bits r/m8 right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorb m8 _Cl: Rotate 8 bits r/m8 right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rorl<Op0, Op1>(pub Op0, pub Op1);

/// rorl r32 imm8: Rotate 32 bits r/m32 right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorl m32 imm8: Rotate 32 bits r/m32 right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorl r32 _1: Rotate 32 bits r/m32 right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorl<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorl m32 _1: Rotate 32 bits r/m32 right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorl<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorl r32 _Cl: Rotate 32 bits r/m32 right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorl<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorl m32 _Cl: Rotate 32 bits r/m32 right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorl<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rorq<Op0, Op1>(pub Op0, pub Op1);

/// rorq r64 imm8: Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorq m64 imm8: Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorq r64 _1: Rotate 64 bits r/m64 right once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorq m64 _1: Rotate 64 bits r/m64 right once. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorq r64 _Cl: Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorq m64 _Cl: Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rorw<Op0, Op1>(pub Op0, pub Op1);

/// rorw r16 imm8: Rotate 16 bits r/m16 right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorw m16 imm8: Rotate 16 bits r/m16 right imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /1 ib
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// rorw r16 _1: Rotate 16 bits r/m16 right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorw m16 _1: Rotate 16 bits r/m16 right once.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorw r16 _Cl: Rotate 16 bits r/m16 right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rorw m16 _Cl: Rotate 16 bits r/m16 right CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Rorw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Roundpd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// roundpd xmm xmm imm8: Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundpd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 09 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x09)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// roundpd xmm m128 imm8: Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundpd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 09 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x09)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Roundps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// roundps xmm xmm imm8: Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundps<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 08 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x08)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// roundps xmm m128 imm8: Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundps<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 08 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x08)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Roundsd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// roundsd xmm xmm imm8: Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundsd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0B /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// roundsd xmm m64 imm8: Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundsd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0B /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Roundss<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// roundss xmm xmm imm8: Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundss<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0A /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// roundss xmm m32 imm8: Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Roundss<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 3A 0A /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x3A)?;
        put(w, 0x0A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Rsqrtps<Op0, Op1>(pub Op0, pub Op1);

/// rsqrtps xmm xmm: Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rsqrtps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 52 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x52)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rsqrtps xmm m128: Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rsqrtps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 52 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x52)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Rsqrtss<Op0, Op1>(pub Op0, pub Op1);

/// rsqrtss xmm xmm: Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rsqrtss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 52 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x52)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// rsqrtss xmm m32: Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Rsqrtss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 52 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x52)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Salb<Op0, Op1>(pub Op0, pub Op1);

/// salb r8 imm8: Multiply r/m8 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// salb m8 imm8: Multiply r/m8 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// salb r8 _1: Multiply r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Salb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salb m8 _1: Multiply r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Salb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salb r8 _Cl: Multiply r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salb m8 _Cl: Multiply r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sall<Op0, Op1>(pub Op0, pub Op1);

/// sall r32 imm8: Multiply r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sall<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sall m32 imm8: Multiply r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sall<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sall r32 _1: Multiply r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sall<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sall m32 _1: Multiply r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sall<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sall r32 _Cl: Multiply r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sall<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sall m32 _Cl: Multiply r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sall<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Salq<Op0, Op1>(pub Op0, pub Op1);

/// salq r64 imm8: Multiply r/m64 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// salq m64 imm8: Multiply r/m64 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// salq r64 _1: Multiply r/m64 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Salq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salq m64 _1: Multiply r/m64 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Salq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salq r64 _Cl: Multiply r/m64 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salq m64 _Cl: Multiply r/m64 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Salw<Op0, Op1>(pub Op0, pub Op1);

/// salw r16 imm8: Multiply r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// salw m16 imm8: Multiply r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// salw r16 _1: Multiply r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Salw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salw m16 _1: Multiply r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Salw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salw r16 _Cl: Multiply r/m16 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// salw m16 _Cl: Multiply r/m16 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Salw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sarb<Op0, Op1>(pub Op0, pub Op1);

/// sarb r8 imm8: Signed divide r/m8 by 2, imm8 time.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarb m8 imm8: Signed divide r/m8 by 2, imm8 time.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarb r8 _1: Signed divide r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarb m8 _1: Signed divide r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarb r8 _Cl: Signed divide r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarb m8 _Cl: Signed divide r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sarl<Op0, Op1>(pub Op0, pub Op1);

/// sarl r32 imm8: Signed divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarl m32 imm8: Signed divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarl r32 _1: Signed divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarl<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarl m32 _1: Signed divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarl<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarl r32 _Cl: Signed divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarl<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarl m32 _Cl: Signed divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarl<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sarq<Op0, Op1>(pub Op0, pub Op1);

/// sarq r64 imm8: Signed divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarq m64 imm8: Signed divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarq r64 _1: Signed divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarq m64 _1: Signed divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarq r64 _Cl: Signed divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarq m64 _Cl: Signed divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sarw<Op0, Op1>(pub Op0, pub Op1);

/// sarw r16 imm8: Signed divide r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarw m16 imm8: Signed divide r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /7 ib
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sarw r16 _1: Signed divide r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarw m16 _1: Signed divide r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarw r16 _Cl: Signed divide r/m16 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sarw m16 _Cl: Signed divide r/m16 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Sarw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /7
        let modrm = ModRM::new(PartOfOpcode(7), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sbbb<Op0, Op1>(pub Op0, pub Op1);

/// sbbb r8 r8: Subtract with borrow r/m8 from r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 1A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x1A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbb r8 m8: Subtract with borrow r/m8 from r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 1A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x1A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbb m8 r8: Subtract with borrow r8 from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 18 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x18)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbb r8 imm8: Subtract with borrow imm8 from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbb m8 imm8: Subtract with borrow imm8 from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbb _Al imm8: Subtract with borrow imm8 from AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 1C ib
        put(w, 0x1C)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Sbbl<Op0, Op1>(pub Op0, pub Op1);

/// sbbl r32 r32: Subtract with borrow r/m32 from r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 1B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x1B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbl r32 m32: Subtract with borrow r/m32 from r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 1B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x1B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbl m32 r32: Subtract with borrow r32 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 19 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x19)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbl r32 imm8: Subtract with borrow sign-extended imm8 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbl m32 imm8: Subtract with borrow sign-extended imm8 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbl r32 imm32: Subtract with borrow imm32 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /3 id
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbl m32 imm32: Subtract with borrow imm32 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /3 id
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbl _Eax imm32: Subtract with borrow imm32 from EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 1D id
        put(w, 0x1D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Sbbq<Op0, Op1>(pub Op0, pub Op1);

/// sbbq r64 r64: Subtract with borrow r/m64 from r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 1B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x1B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbq r64 m64: Subtract with borrow r/m64 from r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 1B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x1B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbq m64 r64: Subtract with borrow r64 from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 19 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x19)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbq r64 imm8: Subtract with borrow sign-extended imm8 from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbq m64 imm8: Subtract with borrow sign-extended imm8 from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbq r64 imm32: Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /3 id
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbq m64 imm32: Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /3 id
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbq _Rax imm32: Subtract with borrow sign-extended imm.32 to 64-bits from RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 1D id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x1D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Sbbw<Op0, Op1>(pub Op0, pub Op1);

/// sbbw r16 r16: Subtract with borrow r/m16 from r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 1B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x1B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbw r16 m16: Subtract with borrow r/m16 from r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 1B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x1B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbw m16 r16: Subtract with borrow r16 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 19 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x19)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sbbw r16 imm8: Subtract with borrow sign-extended imm8 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbw m16 imm8: Subtract with borrow sign-extended imm8 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /3 ib
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbw r16 imm16: Subtract with borrow imm16 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /3 iw
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbw m16 imm16: Subtract with borrow imm16 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /3 iw
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// sbbw _Ax imm16: Subtract with borrow imm16 from AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Sbbw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 1D iw
        put(w, 0x66)?;
        put(w, 0x1D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Seta<Op0>(pub Op0);

/// seta r8: Set byte if above (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Seta<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 97 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x97)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// seta m8: Set byte if above (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Seta<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 97 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x97)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setae<Op0>(pub Op0);

/// setae r8: Set byte if above or equal (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setae<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 93 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x93)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setae m8: Set byte if above or equal (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setae<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 93 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x93)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setb<Op0>(pub Op0);

/// setb r8: Set byte if below (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 92 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x92)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setb m8: Set byte if below (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 92 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x92)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setbe<Op0>(pub Op0);

/// setbe r8: Set byte if below or equal (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setbe<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 96 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x96)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setbe m8: Set byte if below or equal (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setbe<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 96 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x96)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setc<Op0>(pub Op0);

/// setc r8: Set byte if carry (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setc<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 92 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x92)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setc m8: Set byte if carry (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setc<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 92 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x92)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sete<Op0>(pub Op0);

/// sete r8: Set byte if equal (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Sete<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 94 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x94)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sete m8: Set byte if equal (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Sete<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 94 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x94)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setg<Op0>(pub Op0);

/// setg r8: Set byte if greater (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setg<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9F /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setg m8: Set byte if greater (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setg<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9F /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setge<Op0>(pub Op0);

/// setge r8: Set byte if greater or equal (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setge<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9D /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setge m8: Set byte if greater or equal (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setge<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9D /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setl<Op0>(pub Op0);

/// setl r8: Set byte if less (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setl<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9C /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setl m8: Set byte if less (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9C /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setle<Op0>(pub Op0);

/// setle r8: Set byte if less or equal (ZF=1 or SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setle<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9E /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setle m8: Set byte if less or equal (ZF=1 or SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setle<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9E /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setna<Op0>(pub Op0);

/// setna r8: Set byte if not above (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setna<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 96 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x96)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setna m8: Set byte if not above (CF=1 or ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setna<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 96 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x96)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnae<Op0>(pub Op0);

/// setnae r8: Set byte if not above or equal (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnae<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 92 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x92)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnae m8: Set byte if not above or equal (CF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnae<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 92 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x92)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnb<Op0>(pub Op0);

/// setnb r8: Set byte if not below (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnb<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 93 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x93)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnb m8: Set byte if not below (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnb<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 93 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x93)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnbe<Op0>(pub Op0);

/// setnbe r8: Set byte if not below or equal (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnbe<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 97 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x97)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnbe m8: Set byte if not below or equal (CF=0 and ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnbe<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 97 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x97)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnc<Op0>(pub Op0);

/// setnc r8: Set byte if not carry (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnc<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 93 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x93)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnc m8: Set byte if not carry (CF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnc<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 93 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x93)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setne<Op0>(pub Op0);

/// setne r8: Set byte if not equal (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setne<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 95 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x95)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setne m8: Set byte if not equal (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setne<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 95 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x95)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setng<Op0>(pub Op0);

/// setng r8: Set byte if not greater (ZF=1 or SF!= OF)
impl<W: io::Write + ?Sized> WriteInst<W> for Setng<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9E /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setng m8: Set byte if not greater (ZF=1 or SF!= OF)
impl<W: io::Write + ?Sized> WriteInst<W> for Setng<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9E /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnge<Op0>(pub Op0);

/// setnge r8: Set byte if not greater or equal (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnge<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9C /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnge m8: Set byte if not greater or equal (SF!= OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnge<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9C /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnl<Op0>(pub Op0);

/// setnl r8: Set byte if not less (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnl<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9D /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnl m8: Set byte if not less (SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnl<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9D /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9D)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnle<Op0>(pub Op0);

/// setnle r8: Set byte if not less or equal (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnle<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9F /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnle m8: Set byte if not less or equal (ZF=0 and SF=OF).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnle<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9F /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9F)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setno<Op0>(pub Op0);

/// setno r8: Set byte if not overflow (OF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setno<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 91 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x91)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setno m8: Set byte if not overflow (OF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setno<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 91 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x91)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnp<Op0>(pub Op0);

/// setnp r8: Set byte if not parity (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnp<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9B /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnp m8: Set byte if not parity (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnp<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9B /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setns<Op0>(pub Op0);

/// setns r8: Set byte if not sign (SF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setns<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 99 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x99)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setns m8: Set byte if not sign (SF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setns<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 99 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x99)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setnz<Op0>(pub Op0);

/// setnz r8: Set byte if not zero (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnz<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 95 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x95)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setnz m8: Set byte if not zero (ZF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setnz<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 95 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x95)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Seto<Op0>(pub Op0);

/// seto r8: Set byte if overflow (OF=1)
impl<W: io::Write + ?Sized> WriteInst<W> for Seto<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 90 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x90)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// seto m8: Set byte if overflow (OF=1)
impl<W: io::Write + ?Sized> WriteInst<W> for Seto<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 90 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x90)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setp<Op0>(pub Op0);

/// setp r8: Set byte if parity (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setp<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9A /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setp m8: Set byte if parity (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setp<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9A /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setpe<Op0>(pub Op0);

/// setpe r8: Set byte if parity even (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setpe<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9A /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setpe m8: Set byte if parity even (PF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setpe<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9A /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setpo<Op0>(pub Op0);

/// setpo r8: Set byte if parity odd (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setpo<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9B /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setpo m8: Set byte if parity odd (PF=0).
impl<W: io::Write + ?Sized> WriteInst<W> for Setpo<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 9B /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x9B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sets<Op0>(pub Op0);

/// sets r8: Set byte if sign (SF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Sets<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 98 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x98)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sets m8: Set byte if sign (SF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Sets<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 98 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x98)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Setz<Op0>(pub Op0);

/// setz r8: Set byte if zero (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setz<Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 94 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x94)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// setz m8: Set byte if zero (ZF=1).
impl<W: io::Write + ?Sized> WriteInst<W> for Setz<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 94 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x94)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sfence();

/// sfence: Serializes store operations.
impl<W: io::Write + ?Sized> WriteInst<W> for Sfence {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AE F8
        put(w, 0x0F)?;
        put(w, 0xAE)?;
        put(w, 0xF8)?;
        Ok(())
    }
}

pub struct Sgdt<Op0>(pub Op0);

/// sgdt m: Store GDTR to m.
impl<W: io::Write + ?Sized> WriteInst<W> for Sgdt<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 /0
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shlb<Op0, Op1>(pub Op0, pub Op1);

/// shlb r8 imm8: Multiply r/m8 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shlb m8 imm8: Multiply r/m8 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shlb r8 _1: Multiply r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlb m8 _1: Multiply r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlb r8 _Cl: Multiply r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlb m8 _Cl: Multiply r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shldl<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shldl r32 r32 imm8: Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldl<Gpr32, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A4 /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shldl m32 r32 imm8: Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldl<Memory, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A4 /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shldl r32 r32 _Cl: Shift r/m32 to left CL places while shifting bits from r32 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldl<Gpr32, Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A5 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shldl m32 r32 _Cl: Shift r/m32 to left CL places while shifting bits from r32 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldl<Memory, Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F A5 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shldq<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shldq r64 r64 imm8: Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldq<Gpr64, Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F A4 /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xA4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shldq m64 r64 imm8: Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldq<Memory, Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F A4 /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xA4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shldq r64 r64 _Cl: Shift r/m64 to left CL places while shifting bits from r64 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldq<Gpr64, Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F A5 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xA5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shldq m64 r64 _Cl: Shift r/m64 to left CL places while shifting bits from r64 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldq<Memory, Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F A5 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xA5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shldw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shldw r16 r16 imm8: Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldw<Gpr16, Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F A4 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shldw m16 r16 imm8: Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldw<Memory, Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F A4 /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA4)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shldw r16 r16 _Cl: Shift r/m16 to left CL places while shifting bits from r16 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldw<Gpr16, Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F A5 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shldw m16 r16 _Cl: Shift r/m16 to left CL places while shifting bits from r16 in from the right.
impl<W: io::Write + ?Sized> WriteInst<W> for Shldw<Memory, Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F A5 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xA5)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shll<Op0, Op1>(pub Op0, pub Op1);

/// shll r32 imm8: Multiply r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shll<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shll m32 imm8: Multiply r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shll<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shll r32 _1: Multiply r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shll<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shll m32 _1: Multiply r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shll<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shll r32 _Cl: Multiply r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shll<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shll m32 _Cl: Multiply r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shll<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shlq<Op0, Op1>(pub Op0, pub Op1);

/// shlq r64 imm8: Multiply r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shlq m64 imm8: Multiply r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shlq r64 _1: Multiply r/m64 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlq m64 _1: Multiply r/m64 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlq r64 _Cl: Multiply r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlq m64 _Cl: Multiply r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shlw<Op0, Op1>(pub Op0, pub Op1);

/// shlw r16 imm8: Multiply r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shlw m16 imm8: Multiply r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /4 ib
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shlw r16 _1: Multiply r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlw m16 _1: Multiply r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlw r16 _Cl: Multiply r/m16 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shlw m16 _Cl: Multiply r/m16 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shlw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrb<Op0, Op1>(pub Op0, pub Op1);

/// shrb r8 imm8: Unsigned divide r/m8 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrb m8 imm8: Unsigned divide r/m8 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C0 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrb r8 _1: Unsigned divide r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrb<Gpr8, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrb m8 _1: Unsigned divide r/m8 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrb<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D0 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrb r8 _Cl: Unsigned divide r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrb<Gpr8, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrb m8 _Cl: Unsigned divide r/m8 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrb<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D2 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD2)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrdl<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shrdl r32 r32 imm8: Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdl<Gpr32, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AC /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shrdl m32 r32 imm8: Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdl<Memory, Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AC /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shrdl r32 r32 _Cl: Shift r/m32 to right CL places while shifting bits from r32 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdl<Gpr32, Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AD /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrdl m32 r32 _Cl: Shift r/m32 to right CL places while shifting bits from r32 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdl<Memory, Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AD /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrdq<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shrdq r64 r64 imm8: Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdq<Gpr64, Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AC /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shrdq m64 r64 imm8: Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdq<Memory, Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AC /r ib
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shrdq r64 r64 _Cl: Shift r/m64 to right CL places while shifting bits from r64 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdq<Gpr64, Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AD /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrdq m64 r64 _Cl: Shift r/m64 to right CL places while shifting bits from r64 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdq<Memory, Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F AD /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xAD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrdw<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shrdw r16 r16 imm8: Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdw<Gpr16, Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AC /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shrdw m16 r16 imm8: Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdw<Memory, Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AC /r ib
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAC)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shrdw r16 r16 _Cl: Shift r/m16 to right CL places while shifting bits from r16 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdw<Gpr16, Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AD /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrdw m16 r16 _Cl: Shift r/m16 to right CL places while shifting bits from r16 in from the left.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrdw<Memory, Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F AD /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAD)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrl<Op0, Op1>(pub Op0, pub Op1);

/// shrl r32 imm8: Unsigned divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrl m32 imm8: Unsigned divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // C1 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrl r32 _1: Unsigned divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrl<Gpr32, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrl m32 _1: Unsigned divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrl<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D1 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrl r32 _Cl: Unsigned divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrl<Gpr32, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrl m32 _Cl: Unsigned divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrl<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // D3 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrq<Op0, Op1>(pub Op0, pub Op1);

/// shrq r64 imm8: Unsigned divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrq m64 imm8: Unsigned divide r/m32 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ C1 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrq r64 _1: Unsigned divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrq<Gpr64, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrq m64 _1: Unsigned divide r/m32 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrq<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D1 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrq r64 _Cl: Unsigned divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrq<Gpr64, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrq m64 _Cl: Unsigned divide r/m32 by 2, CL times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrq<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ D3 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shrw<Op0, Op1>(pub Op0, pub Op1);

/// shrw r16 imm8: Unsigned divide r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrw m16 imm8: Unsigned divide r/m16 by 2, imm8 times.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 C1 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// shrw r16 _1: Unsigned divide r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrw<Gpr16, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrw m16 _1: Unsigned divide r/m16 by 2, once.
impl<W: io::Write + ?Sized> WriteInst<W> for Shrw<Memory, _1> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D1 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrw r16 _Cl: Unsigned divide r/m16 by 2, CL times
impl<W: io::Write + ?Sized> WriteInst<W> for Shrw<Gpr16, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// shrw m16 _Cl: Unsigned divide r/m16 by 2, CL times
impl<W: io::Write + ?Sized> WriteInst<W> for Shrw<Memory, _Cl> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 D3 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xD3)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Shufpd<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shufpd xmm xmm imm8: Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Shufpd<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C6 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shufpd xmm m128 imm8: Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Shufpd<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C6 /r ib
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Shufps<Op0, Op1, Op2>(pub Op0, pub Op1, pub Op2);

/// shufps xmm xmm imm8: Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Shufps<Xmm, Xmm, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C6 /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

/// shufps xmm m128 imm8: Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Shufps<Xmm, Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C6 /r ib
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.2.to_le_bytes())?;
        Ok(())
    }
}

pub struct Sidt<Op0>(pub Op0);

/// sidt m: Store IDTR to m.
impl<W: io::Write + ?Sized> WriteInst<W> for Sidt<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sqrtpd<Op0, Op1>(pub Op0, pub Op1);

/// sqrtpd xmm xmm: Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sqrtpd xmm m128: Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sqrtps<Op0, Op1>(pub Op0, pub Op1);

/// sqrtps xmm xmm: Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sqrtps xmm m128: Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sqrtsd<Op0, Op1>(pub Op0, pub Op1);

/// sqrtsd xmm xmm: Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sqrtsd xmm m64: Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Sqrtss<Op0, Op1>(pub Op0, pub Op1);

/// sqrtss xmm xmm: Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// sqrtss xmm m32: Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Sqrtss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 51 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x51)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Stc();

/// stc: Set CF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Stc {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F9
        put(w, 0xF9)?;
        Ok(())
    }
}

pub struct Std();

/// std: Set DF flag.
impl<W: io::Write + ?Sized> WriteInst<W> for Std {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FD
        put(w, 0xFD)?;
        Ok(())
    }
}

pub struct Sti();

/// sti: Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.
impl<W: io::Write + ?Sized> WriteInst<W> for Sti {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // FB
        put(w, 0xFB)?;
        Ok(())
    }
}

pub struct Stmxcsr<Op0>(pub Op0);

/// stmxcsr m32: Store contents of MXCSR register to m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Stmxcsr<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F AE /3
        let modrm = ModRM::new(PartOfOpcode(3), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xAE)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Str<Op0>(pub Op0);

/// str r16: Stores segment selector from TR in r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Str<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 00 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// str m16: Stores segment selector from TR in r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Str<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 00 /1
        let modrm = ModRM::new(PartOfOpcode(1), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Subb<Op0, Op1>(pub Op0, pub Op1);

/// subb r8 r8: Subtract r/m8 from r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Subb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 2A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subb r8 m8: Subtract r/m8 from r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Subb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 2A /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x2A)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subb m8 r8: Subtract r8 from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Subb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 28 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x28)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subb r8 imm8: Subtract imm8 from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Subb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subb m8 imm8: Subtract imm8 from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Subb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subb _Al imm8: Subtract imm8 from AL.
impl<W: io::Write + ?Sized> WriteInst<W> for Subb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 2C ib
        put(w, 0x2C)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Subl<Op0, Op1>(pub Op0, pub Op1);

/// subl r32 r32: Subtract r/m32 from r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 2B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subl r32 m32: Subtract r/m32 from r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 2B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subl m32 r32: Subtract r32 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 29 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subl r32 imm8: Subtract sign-extended imm8 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subl m32 imm8: Subtract sign-extended imm8 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subl r32 imm32: Subtract imm32 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /5 id
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subl m32 imm32: Subtract imm32 from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /5 id
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subl _Eax imm32: Subtract imm32 from EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Subl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 2D id
        put(w, 0x2D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Subpd<Op0, Op1>(pub Op0, pub Op1);

/// subpd xmm xmm: Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subpd xmm m128: Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Subps<Op0, Op1>(pub Op0, pub Op1);

/// subps xmm xmm: Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subps xmm m128: Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Subq<Op0, Op1>(pub Op0, pub Op1);

/// subq r64 r64: Subtract r/m64 from r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 2B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subq r64 m64: Subtract r/m64 from r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 2B /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subq m64 r64: Subtract r64 from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 29 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subq r64 imm8: Subtract sign-extended imm8 from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subq m64 imm8: Subtract sign-extended imm8 from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subq r64 imm32: Subtract imm32 sign-extended to 64-bits from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /5 id
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subq m64 imm32: Subtract imm32 sign-extended to 64-bits from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /5 id
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subq _Rax imm32: Subtract imm32 sign-extended to 64-bits from RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Subq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 2D id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x2D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Subsd<Op0, Op1>(pub Op0, pub Op1);

/// subsd xmm xmm: Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subsd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subsd xmm m64: Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subsd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F2 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF2)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Subss<Op0, Op1>(pub Op0, pub Op1);

/// subss xmm xmm: Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subss xmm m32: Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Subss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F3 0F 5C /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0xF3)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x5C)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Subw<Op0, Op1>(pub Op0, pub Op1);

/// subw r16 r16: Subtract r/m16 from r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 2B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subw r16 m16: Subtract r/m16 from r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 2B /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x2B)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subw m16 r16: Subtract r16 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 29 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x29)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// subw r16 imm8: Subtract sign-extended imm8 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subw m16 imm8: Subtract sign-extended imm8 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /5 ib
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subw r16 imm16: Subtract imm16 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /5 iw
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subw m16 imm16: Subtract imm16 from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /5 iw
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// subw _Ax imm16: Subtract imm16 from AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Subw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 2D iw
        put(w, 0x66)?;
        put(w, 0x2D)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Swapgs();

/// swapgs: Exchanges the current GS base register value with the value contained in MSR address C0000102H.
impl<W: io::Write + ?Sized> WriteInst<W> for Swapgs {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 F8
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, 0xF8)?;
        Ok(())
    }
}

pub struct Testb<Op0, Op1>(pub Op0, pub Op1);

/// testb r8 r8: AND r8 with r/m8; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 84 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x84)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testb m8 r8: AND r8 with r/m8; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 84 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x84)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testb r8 imm8: AND imm8 with r/m8; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testb m8 imm8: AND imm8 with r/m8; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F6 /0 ib
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF6)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testb _Al imm8: AND imm8 with AL; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // A8 ib
        put(w, 0xA8)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Testl<Op0, Op1>(pub Op0, pub Op1);

/// testl r32 r32: AND r32 with r/m32; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 85 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x85)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testl m32 r32: AND r32 with r/m32; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 85 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x85)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testl r32 imm32: AND imm32 with r/m32; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testl m32 imm32: AND imm32 with r/m32; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // F7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testl _Eax imm32: AND imm32 with EAX; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // A9 id
        put(w, 0xA9)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Testq<Op0, Op1>(pub Op0, pub Op1);

/// testq r64 r64: AND r64 with r/m64; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 85 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x85)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testq m64 r64: AND r64 with r/m64; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 85 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x85)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testq r64 imm32: AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testq m64 imm32: AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ F7 /0 id
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testq _Rax imm32: AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ A9 id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0xA9)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Testw<Op0, Op1>(pub Op0, pub Op1);

/// testw r16 r16: AND r16 with r/m16; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 85 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x85)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testw m16 r16: AND r16 with r/m16; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 85 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x85)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// testw r16 imm16: AND imm16 with r/m16; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /0 iw
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testw m16 imm16: AND imm16 with r/m16; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 F7 /0 iw
        let modrm = ModRM::new(PartOfOpcode(0), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0xF7)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// testw _Ax imm16: AND imm16 with AX; set SF, ZF, PF according to result.
impl<W: io::Write + ?Sized> WriteInst<W> for Testw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 A9 iw
        put(w, 0x66)?;
        put(w, 0xA9)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Ucomisd<Op0, Op1>(pub Op0, pub Op1);

/// ucomisd xmm xmm: Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Ucomisd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 2E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// ucomisd xmm m64: Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Ucomisd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 2E /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Ucomiss<Op0, Op1>(pub Op0, pub Op1);

/// ucomiss xmm xmm: Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Ucomiss<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 2E /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// ucomiss xmm m32: Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
impl<W: io::Write + ?Sized> WriteInst<W> for Ucomiss<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 2E /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x2E)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Ud2();

/// ud2: Raise invalid opcode exception.
impl<W: io::Write + ?Sized> WriteInst<W> for Ud2 {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 0B
        put(w, 0x0F)?;
        put(w, 0x0B)?;
        Ok(())
    }
}

pub struct Unpckhpd<Op0, Op1>(pub Op0, pub Op1);

/// unpckhpd xmm xmm: Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpckhpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 15 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// unpckhpd xmm m128: Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpckhpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 15 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Unpckhps<Op0, Op1>(pub Op0, pub Op1);

/// unpckhps xmm xmm: Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpckhps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 15 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// unpckhps xmm m128: Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpckhps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 15 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x15)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Unpcklpd<Op0, Op1>(pub Op0, pub Op1);

/// unpcklpd xmm xmm: Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpcklpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 14 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// unpcklpd xmm m128: Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpcklpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 14 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Unpcklps<Op0, Op1>(pub Op0, pub Op1);

/// unpcklps xmm xmm: Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpcklps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 14 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// unpcklps xmm m128: Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Unpcklps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 14 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x14)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Verr<Op0>(pub Op0);

/// verr r16: Set ZF=1 if segment specified with r/m16 can be read.
impl<W: io::Write + ?Sized> WriteInst<W> for Verr<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 00 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// verr m16: Set ZF=1 if segment specified with r/m16 can be read.
impl<W: io::Write + ?Sized> WriteInst<W> for Verr<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 00 /4
        let modrm = ModRM::new(PartOfOpcode(4), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Verw<Op0>(pub Op0);

/// verw r16: Set ZF=1 if segment specified with r/m16 can be written.
impl<W: io::Write + ?Sized> WriteInst<W> for Verw<Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 00 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// verw m16: Set ZF=1 if segment specified with r/m16 can be written.
impl<W: io::Write + ?Sized> WriteInst<W> for Verw<Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 00 /5
        let modrm = ModRM::new(PartOfOpcode(5), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x00)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Wbinvd();

/// wbinvd: Write back and flush Internal caches; initiate writing-back and flushing of external caches.
impl<W: io::Write + ?Sized> WriteInst<W> for Wbinvd {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 09
        put(w, 0x0F)?;
        put(w, 0x09)?;
        Ok(())
    }
}

pub struct Wrmsr();

/// wrmsr: Write the value in EDX:EAX to MSR specified by ECX.
impl<W: io::Write + ?Sized> WriteInst<W> for Wrmsr {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 30
        put(w, 0x0F)?;
        put(w, 0x30)?;
        Ok(())
    }
}

pub struct Xaddb<Op0, Op1>(pub Op0, pub Op1);

/// xaddb r8 r8: Exchange r8 and r/m8; load sum into r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C0 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xaddb m8 r8: Exchange r8 and r/m8; load sum into r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C0 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC0)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xaddl<Op0, Op1>(pub Op0, pub Op1);

/// xaddl r32 r32: Exchange r32 and r/m32; load sum into r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xaddl m32 r32: Exchange r32 and r/m32; load sum into r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F C1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xaddq<Op0, Op1>(pub Op0, pub Op1);

/// xaddq r64 r64: Exchange r64 and r/m64; load sum into r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F C1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xaddq m64 r64: Exchange r64 and r/m64; load sum into r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 0F C1 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x0F)?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xaddw<Op0, Op1>(pub Op0, pub Op1);

/// xaddw r16 r16: Exchange r16 and r/m16; load sum into r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C1 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xaddw m16 r16: Exchange r16 and r/m16; load sum into r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xaddw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F C1 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0xC1)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xchgb<Op0, Op1>(pub Op0, pub Op1);

/// xchgb r8 r8: Exchange byte from r/m8 with r8 (byte register).
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 86 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x86)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgb r8 m8: Exchange byte from r/m8 with r8 (byte register).
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 86 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x86)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgb m8 r8: Exchange r8 (byte register) with byte from r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 86 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x86)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xchgl<Op0, Op1>(pub Op0, pub Op1);

/// xchgl r32 r32: Exchange doubleword from r/m32 with r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 87 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgl r32 m32: Exchange doubleword from r/m32 with r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 87 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgl r32 _Eax: Exchange EAX with r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgl<Gpr32, _Eax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 90 +rd
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(false))?;
        put(w, 0x90 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// xchgl m32 r32: Exchange r32 with doubleword from r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 87 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgl _Eax r32: Exchange r32 with EAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgl<_Eax, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 90 +rd
        let rio = RegInOpcode::from(self.1);
        puts(w, rio.rex_byte(false))?;
        put(w, 0x90 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

pub struct Xchgq<Op0, Op1>(pub Op0, pub Op1);

/// xchgq r64 r64: Exchange quadword from r/m64 with r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 87 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgq r64 m64: Exchange quadword from r/m64 with r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 87 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgq r64 _Rax: Exchange RAX with r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgq<Gpr64, _Rax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 90 +ro
        let rio = RegInOpcode::from(self.0);
        puts(w, rio.rex_byte(true))?;
        put(w, 0x90 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// xchgq m64 r64: Exchange r64 with quadword from r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 87 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgq _Rax r64: Exchange r64 with RAX.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgq<_Rax, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 90 +ro
        let rio = RegInOpcode::from(self.1);
        puts(w, rio.rex_byte(true))?;
        put(w, 0x90 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

pub struct Xchgw<Op0, Op1>(pub Op0, pub Op1);

/// xchgw r16 r16: Exchange word from r/m16 with r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 87 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgw r16 m16: Exchange word from r/m16 with r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 87 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgw r16 _Ax: Exchange AX with r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgw<Gpr16, _Ax> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 90 +rw
        let rio = RegInOpcode::from(self.0);
        put(w, 0x66)?;
        puts(w, rio.rex_byte(false))?;
        put(w, 0x90 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

/// xchgw m16 r16: Exchange r16 with word from r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 87 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x87)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xchgw _Ax r16: Exchange r16 with AX.
impl<W: io::Write + ?Sized> WriteInst<W> for Xchgw<_Ax, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 90 +rw
        let rio = RegInOpcode::from(self.1);
        put(w, 0x66)?;
        puts(w, rio.rex_byte(false))?;
        put(w, 0x90 + rio.byte_added_to_opcode)?;
        Ok(())
    }
}

pub struct Xorb<Op0, Op1>(pub Op0, pub Op1);

/// xorb r8 r8: r8 XOR r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorb<Gpr8, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 32 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x32)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorb r8 m8: r8 XOR r/m8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorb<Gpr8, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 32 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x32)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorb m8 r8: r/m8 XOR r8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorb<Memory, Gpr8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 30 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x30)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorb r8 imm8: r/m8 XOR imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorb<Gpr8, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorb m8 imm8: r/m8 XOR imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorb<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 80 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x80)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorb _Al imm8: AL XOR imm8.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorb<_Al, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 34 ib
        put(w, 0x34)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Xorl<Op0, Op1>(pub Op0, pub Op1);

/// xorl r32 r32: r32 XOR r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Gpr32, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 33 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorl r32 m32: r32 XOR r/m32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Gpr32, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 33 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorl m32 r32: r/m32 XOR r32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Memory, Gpr32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 31 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x31)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorl r32 imm8: r/m32 XOR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Gpr32, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorl m32 imm8: r/m32 XOR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 83 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorl r32 imm32: r/m32 XOR imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Gpr32, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /6 id
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorl m32 imm32: r/m32 XOR imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 81 /6 id
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorl _Eax imm32: EAX XOR imm32.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorl<_Eax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 35 id
        put(w, 0x35)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Xorpd<Op0, Op1>(pub Op0, pub Op1);

/// xorpd xmm xmm: Bitwise exclusive-OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorpd<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 57 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x57)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorpd xmm m128: Bitwise exclusive-OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorpd<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 0F 57 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x57)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xorps<Op0, Op1>(pub Op0, pub Op1);

/// xorps xmm xmm: Bitwise exclusive-OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorps<Xmm, Xmm> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 57 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x57)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorps xmm m128: Bitwise exclusive-OR of xmm2/m128 and xmm1.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorps<Xmm, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 57 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x0F)?;
        put(w, 0x57)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

pub struct Xorq<Op0, Op1>(pub Op0, pub Op1);

/// xorq r64 r64: r64 XOR r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Gpr64, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 33 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorq r64 m64: r64 XOR r/m64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Gpr64, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 33 /r
        let modrm = ModRM::new(self.0, self.1);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorq m64 r64: r/m64 XOR r64.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Memory, Gpr64> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 31 /r
        let modrm = ModRM::new(self.1, self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x31)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorq r64 imm8: r/m64 XOR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Gpr64, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorq m64 imm8: r/m64 XOR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 83 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorq r64 imm32: r/m64 XOR imm32 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Gpr64, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /6 id
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorq m64 imm32: r/m64 XOR imm32 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<Memory, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 81 /6 id
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        puts(w, modrm.rex_byte(true))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorq _Rax imm32: RAX XOR imm32 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorq<_Rax, i32> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // REX.W+ 35 id
        puts(w, RexPrefix::default().byte(true, false, false, false))?;
        put(w, 0x35)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Xorw<Op0, Op1>(pub Op0, pub Op1);

/// xorw r16 r16: r16 XOR r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Gpr16, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 33 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorw r16 m16: r16 XOR r/m16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Gpr16, Memory> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 33 /r
        let modrm = ModRM::new(self.0, self.1);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x33)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorw m16 r16: r/m16 XOR r16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Memory, Gpr16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 31 /r
        let modrm = ModRM::new(self.1, self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x31)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        Ok(())
    }
}

/// xorw r16 imm8: r/m16 XOR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Gpr16, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorw m16 imm8: r/m16 XOR imm8 (sign-extended).
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Memory, i8> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 83 /6 ib
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x83)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorw r16 imm16: r/m16 XOR imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Gpr16, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /6 iw
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorw m16 imm16: r/m16 XOR imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<Memory, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 81 /6 iw
        let modrm = ModRM::new(PartOfOpcode(6), self.0);
        put(w, 0x66)?;
        puts(w, modrm.rex_byte(false))?;
        put(w, 0x81)?;
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

/// xorw _Ax imm16: AX XOR imm16.
impl<W: io::Write + ?Sized> WriteInst<W> for Xorw<_Ax, i16> {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 66 35 iw
        put(w, 0x66)?;
        put(w, 0x35)?;
        puts(w, self.1.to_le_bytes())?;
        Ok(())
    }
}

pub struct Xsetbv();

/// xsetbv: Write the value in EDX:EAX to the XCR specified by ECX.
impl<W: io::Write + ?Sized> WriteInst<W> for Xsetbv {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // 0F 01 D1
        put(w, 0x0F)?;
        put(w, 0x01)?;
        put(w, 0xD1)?;
        Ok(())
    }
}

fn put(w: &mut (impl io::Write + ?Sized), b: u8) -> io::Result<()> {
    w.write_all(&[b])
}

fn puts(w: &mut (impl io::Write + ?Sized), bs: impl IntoIterator<Item = u8>) -> io::Result<()> {
    for b in bs {
        w.write_all(&[b])?;
    }
    Ok(())
}
